


inputs files :
  * source file` .C,.cpp,.cc`
  * header file `.h,.H,.hpp,.hh`

each source filee corresponds to a compilation unit  that forms a logicaly organized piece of code.
What happen when it is compiled :
    * **preprocessing** 
    The *preprocessor* `cpp` opens the source file within a context of predefined `macros` and a list of headers directories ;
    it open the translation-unit output file.
    preprocessor read input file line by line and tranlate to output lines according to preprocessing directives :
        ** `#include` filename means copy the content of filename in the output file.
        ** `#if/else/endif/ifdef` directives are used to drive what is copied from source to output.
        ** `#define` directives are interpreted as new macros in addition to the predefined macros 
            if `#define NUMBER_MAGIC  0xbabecafe`[^1] is found then preprocessor does text-editor like replacement 
                - everywhere it finds `NUMBER_MAGIC`, changes it to `0xbabecafe`.
        *  any comment is recognized and removed from the output.
        ** other lines are actual c++ code are copied to output with macro substitutions 
        ** preprocessor adds `# line` directives to the output with source file references.
    The resulting output file is a bunch of c++ source code without comments and # statements except ` #line`.
    *  the translation-unit is self-contained and completely independent of other files ; it is the input of the compiler.
    The compiler parses the translation-unit and creates a tree data-structure named AST Abstract-Syntax-Tree.
    # lines directived are interpreted to decorated the tree nodes with source files references.
    if the AST cannot be contructed in accordance with c++ syntax rules then the compiler print the offending lines and stops.
        ** this is what is called syntax errors.
    The compiler schedule several pass on the tree for semantic analysis front compiler, the tree transformation begins other pass are scheduled
    that create the next tree called  IR Internal-Representation. 
    For c++, the compiler executes passes where high-level contructs of c++ like `class` semantic and `template` 
    semantic are refined :
        *** instanciate templates "only-if" they are used ; unused template code is removed.
        *** instanciate class default implementation like constructors and the virtual table.
    if the IR cannot be contructed in accordance with c++ semantic rules then the compiler print the offending lines and stops.
        ** this is what is called semantic errors.
    * At this stage, the assemby code can be generated by backend compiler ; IR is converted to another tree in SSA form by dozen of passes:
    A modern compiler has more the 200 passes like constant propagation for instance the result is written out to assembly.
        ** assembler converts the compiler output to machine code resulting in a object file conform today to ELF.
        ** an ELF file contains on one hand a annotation for all symbol refference and the list of defined symbols.
        For a function `f()` ; the is a list of every locations where `f()` is called and a definition that `f()` starts here in elf file.
        The symbols are in the symbol table and each symbol reference are listed in the relocation table.
        Actual code and data are stored in sections like `.text `and `.data`
    
    Real C++ programs have a large number of source files when each source file is compiled then linker assemble the result with 
    precompiled libraries to create the application executable binary file:
        * libraries are standard collections of object modules that have been precompiled.
          ** Important precision : a library is the interface header files + the object module archive
              - library foo is at minimal the `include/foo.h` file + `lib/libfoo.so` file.
              - the only symbol exported by library foo is the function foo() which mean :
                `include/foo.h` contains `foo()` function prototype.
                `lib/libfoo.so` contains `foo()` function definition.
         A library is injected in the application during preprocessing via interface include file and during linking via 
            object code ; remember that class declarations and function prototypes are supposed to tell the compiler
        everything it needs to know in order to compile code that uses the class or calls the function.
        * C++ template allows to have library source code in header files but as a template
          - if no object module archive is needed this is a so-called **header-only** library.
    
    * linker assembles object modules and decides layout in memory according to the ld script.
      the result is the executable file.
      if the binary cannot be contructed  then the linker print the offending symbols and stops:
      Linker has to be able to match every function call with a function definition
      This is a common error which means that we forget to define a function 
          - linker gives you "undefined symbol" error 
            Somewhere `foo()` is called, but linker can't find the code for `foo()`. This is different from undefined errors
            produced by the compiler. Is `foo()` really absent, is the library libfoo.so not specified to linker and so on.
          - gcc says "ld" before the error message.
      All functions that are called must be defined somewhere in the whole program, and only once in the
      whole program : 
          - linker gives you "duplicated symbol definition" error.
      Linkage means whether the symbol can be used by the linker across object modules. There is external and internal linkage.
      Ordinary functions are defined with external linkage when the compiler puts an annotation in the object module 
      that these names are available outside the module for the linker to match up with calls or extern declarations.
      In order to define a function with internal linkage just tell the compiler with` static` [^3] annotation; the linker 
      can not use it in other modules.
      In c++, prefer namespaces and class private/public facilities[^2]. 
     

Header file :
One-Definition Rule (ODR): it is an error to declare twice a struct or class of the same name, and it is
an error to define twice a function of same signature in C++.
Multiple declarations prototypes of a function as long as they are compatible, deault parameters values are specified once.
The .h file has to have every declaration in it that's needed about the other module 

Good habit the pattern called an `INCLUDE GUARD` against duplicate includes

    #ifndef FOO_H
    #define FOO_H
    template <typename T> 
    foo(T value) 
    {
    }
    #endif // FOO_H
    or 
    #pragma once
    
Note: some pepole advocates the usage of `__FOO_H__` or` _FOO_H` ... ; **do not do that** leading underscore are reserved for standards line C++ standard, POSIX and so on
A name collision with standards quite often are really hard to find.
System header files <stdlib.h>, <vector> already have their own include guards.

In pratice; a c++ file containing only the line `#include "foo.h"`MUST compile.
Good habit : if` foo.h` exists a corresponding `foo.cc` must exists at least with only the line `#include "foo.h"`.
This is a defensive programing method that have the additional benefaet of helping IDE and CMAKE tools.

[^1]: convention to make preprocessor symbols all upper case

[^2]:  Example global variables in anonymous namespaces.

[^3]: `static `keyword is complicated to understand ; many usage like class-wide member variables and functions.
