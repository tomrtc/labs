Pseudorandom Rehash
The first class of rehashing algorithms is the pseudorandom rehash and is based upon a pseudorandom number generator. The pseudorandom number generator used is not important, but it must be of the non-repeating variety. That is, it must generate all possible values before any previous value is repeated. It must also generate all of the integers in the range 0, ..., N where N is the table size. The following simple procedure incorporates a common random number generator and will perform the rehash function for any table of size N = 2M. The variable R is internal to the rehashing function, but it must be preset to one whenever the function HASH is initiated (ie: step 1 of algorithm 5).

[6]	REHASH (I,J):
	1.  R := REMAINDER (R*5 / N*4);
	2.  REHASH := (R/4 + J) [mod N];

If you're seeking the most efficient implementation of this one, the REMAINDER(R*5/N*4) is just the rightmost M+2 bits of R*5 because N=2M and 4*N=22*2M=2M+2. Furthermore, the divide operation in step 2 can be replaced by a right shift of two positions. Finally, if you think of R*5 as R*4+R, then it's easy to see how to reduce that multiply operation to left shift and addition operations.
Let's look at the sequence generated by this rehash routine. If our table is eight entries long and the initial hash index is, let's say, 4, then R takes on the values 1,6,7,4,5,2,3,1, so the table would be searched in the order 4(initial index),5,2,3,0,1,6,7. How does this avoid the clustering situation? If we chose another initial index, say, 5, then the table is searched in the order 5(initial index),6,3,4,1,2,7,0. As you see, the entry searched after entry 5 will depend upon the initial index. If the initial index was 4, then 2 is searched after 5; but if the initial index was 5, then 6 follows 5. In a linear search, 6 always follows 5. This dependence upon the initial index is what avoids the clustering. 

Quadratic Rehash
A second class of algorithms for rehashing is the quadratic rehash and these are based upon a quadratic function. The major drawback with most algorithms in this class is that they search only one half of the table, so two different rehashing algorithms are required. The most efficient quadratic rehash, and one which does search the entire table, was first introduced by Colin Day [see bibliography, reference 1]. Day's algorithm can only be applied to a table whose size is a prime number that produces a remainder of 1 when it is divided by 4 (eg: 5=4*1+1, 401=4*1+1). At first glance, this appears to place a great many restrictions on the allowable size of the table; but don't despair, because experience will show that a number satisfying the required condition can be found very near any desired value. Be certain that you use an acceptable number or the procedure will not search all locations of the table. Like the last rehashing function an internal variable is used. The variable, R, must be preset to (-N) whenever the function HASH is called. The quadratic rehash process is (remember that the mod operation is just a conditional subtraction):

[7]	REHASH(I,J):
	1.  R:=R + 2;
	2.  REHASH := (I + /R/) [mod N];

If we look at the sequence generated by this procedure, we see that R takes on the values (for a table of size 11=4*2+3) -11,-9,-7,-5,-3,-1,1,3,5,7,9,11. Therefore, if the initial index were 4 the table would be searched in the order: 4(initial index),2,9,3,6,7,8,0,5,1,10. One major difference between this algorithm and the random rehash is that this one calculates the next index based on the previous one. The random rehash calculates the next index based on the initial index.
Weighted Increment Rehash
The last, and probably the simplest, method for performing the rehash is called a weighted increment [see bibliography, reference 2]. This one is unique because it uses the hash index to calculate an increment which is in turn used to step through the table. The table size is again restricted to a power of 2, and whenever the function HASH is called, the variable R is preset to (2*J+1)[mod N], where J is the initial hash index. The weighted increment method is:

[8]	REHASH(I,J):
	1.  REHASH := (I+R) [mod N];

This process is very much like a linear rehash. In fact if R were always set to 1 it would be a linear rehash, however R depends on the hash index. If our table is eight entries long and the initial index is 5 then R=2*5+1[mod 8]=11-8=3 and the table items are searched in the order 5,0,3,6,1,4,7,2. Since the increment is a constant for any particular hash index, we can improve the basic hash algorithm when using this rehash technique. You will notice that all memory references are of the form (TABLE+I*B), where B is the number of bytes. We can avoid that multiply by including it in the computation of R. If we let R=((2*J+1)[mod N])*B, then all of the table references become (TABLE+I). If we also initialize I to TABLE+HASH(KEY) we can make all references as just (I). 

Fusionner bits à partir de deux valeurs selon un masque

unsigned int a; / / valeur à fusionner dans les bits non masqués
unsigned int b; / / valeur de fusionner en bits masqués
unsigned int masque; / / 1, où les bits de b devrait être choisi; 0 d'où a.
unsigned int r; / / résultat de (a & ~ masque) | (b & masque) va ici

r = a ^ ((a ^ b) Masque &);

Cette rase d'une opération de la façon évidente de la combinaison de deux ensembles de bits selon un masque de bits. Si le masque est une constante, alors il peut y avoir aucun avantage.

Ron Jeffery m'a envoyé ça sur le Février 9, 2006.


Conditionnellement nier une valeur sans branchement
Si vous avez besoin de nier que quand un drapeau est faux, puis utilisez les suivantes pour éviter de branchement:

bool fDontNegate; / / Drapeau indiquant que nous ne devraient pas annuler c.
int v; / / valeur d'entrée pour annuler si fDontNegate est fausse.
int r; / / result = fDontNegate? v: v-;

r = (fDontNegate ^ (fDontNegate - 1)) * v;

Si vous avez besoin de nier que quand un drapeau est vrai, alors utilisez ceci:

bool fNegate; / / Drapeau indiquant si on doit annuler c.
int v; / / valeur d'entrée pour annuler si fNegate est vrai.
int r; / / result = fNegate? -V: v;

r = (v ^-fNegate) + fNegate;

Avraham Plotnitzky suggéré-je ajouter de la première version sur Juin 2, 2009. Motivé pour éviter les multiplier, je suis venu avec la deuxième version le 8 Juin 2009. Alfonso De Gregorio a fait remarquer que certains parens étaient manquantes sur Novembre 26, 2009, et a reçu une prime de bug.

Déterminer si un mot a un octet égal à n
On peut vouloir savoir si l'un octet dans un mot a une valeur spécifique. Pour ce faire, nous pouvons XOR la ​​valeur à tester avec un mot qui a été rempli avec les valeurs d'octets dans laquelle nous sommes intéressés. Parce XOR une valeur avec lui-même se traduit par un octet nul et non nul sinon, nous pouvons passer le résultat à haszero.

# Define HasValue (x, n) \
(Haszero ((x) ^ (~ 0UL/255 * (n))))

Stephen M Bennet a suggéré ceci sur 13 Décembre 2009, après la lecture de l'entrée pour haszero.

Déterminer si un mot a un octet de moins de n
Teste si un mot x contient un octet non signé avec la valeur <n. Spécifiquement pour n = 1, elle peut être utilisée pour trouver un 0-octets en examinant une à une heure de temps, ou tout octet par XOR x avec un premier masque. Utilise 4 arithmétique / opérations logiques quand n est constante.

Exigences: x> = 0; 0 <= n <= 128

# Define hasless (x, n) (((x) - ~ 0UL/255 * (n ))&~( x) & ~ 0UL/255 * 128)

Pour compter le nombre d'octets dans X qui est inférieur à n dans 7 opérations, l'utilisation

# Define innombrables (x, n) \
(((~ 0UL/255 * (127 + (n ))-(( x) & ~ 0UL/255 * 127 ))&~( x) & ~ 0UL/255 * 128) / 128% 255)

Juha Järvi a envoyé cette technique astucieuse pour moi, le 6 avril 2005. La macro innombrables a été ajoutée par Sean Anderson, le 10 avril 2005, inspiré par countmore Juha, en dessous.

Déterminer si un mot a un octet supérieur à n
Teste si un mot x contient un octet non signé avec une valeur> n. Utilise 3 arithmétique / opérations logiques quand n est constante.

Exigences: x> = 0; 0 <= n <= 127

# Define hasmore (x, n) (((x) + ~ * 0UL/255 (127 - (n)) | (x)) & ~ 0UL/255 * 128)

Pour compter le nombre d'octets dans X qui sont plus que n en 6 opérations, utilisez:

# Define countmore (x, n) \
((((( X) & ~ 0UL/255 * 127) + ~ * 0UL/255 (127 - (n)) | (x)) & ~ 0UL/255 * 128) / 128% 255)

Le hasmore macro a été suggéré par Juha Järvi, le 6 avril 2005, et il a ajouté countmore le 8 avril 2005.

Déterminer si un mot a un octet compris entre m et n
Lorsque m <n, cette technique si les tests un mot x contient une valeur d'octet non signé, tel que m <<valeur n. Il utilise 7 arithmétique / opérations logiques lorsque n et m sont constants.

Remarque: octets qui n égal peut être rapportée par likelyhasbetween que les faux positifs, ce qui devrait être vérifié par le caractère si un certain résultat est nécessaire.

Exigences: x> = 0; 0 <= m <= 127; 0 <= n <= 128

# Define likelyhasbetween (x, m, n) \
((((X) - ~ 0UL/255 * (n ))&~( x) & ((x) & ~ 0UL/255 * 127) + ~ 0UL/255 * (127 - (m )))&~ 0UL/255 * 128)

Cette technique serait approprié pour un prétest rapide. Une variation qui prend un fonctionnement plus (8 au total pour les constantes m et n), mais donne la réponse exacte est:

# Define hasbetween (x, m, n) \
((~ 0UL/255 * (127 + (n ))-(( x) & ~ 0UL/255 * 127) & ~ (x) & ((x) & ~ 0UL/255 * 127) + ~ 0UL/255 * (127 - (m )))&~ 0UL/255 * 128)

Pour compter le nombre d'octets dans X qui se situent entre m et n (exclusif) dans 10 opérations, utilisez:

# Define countbetween (x, m, n) (hasbetween (x, m, n) / 128% 255)

Juha Järvi suggéré likelyhasbetween le 6 avril 2005. De là, Sean Anderson a créé hasbetween et countbetween le 10 avril 2005.
