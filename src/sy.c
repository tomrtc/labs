#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "hexdump.h" 


/* gcc -o sy sy.c pcap.c hexdump.c */

/* UTF-8 map
   Number of bytes 	Bits for code point 	First code point 	Last code point 	Byte 1  	Byte 2 	         Byte 3 	Byte 4
   1                       	7 	                 U+0000 	         U+007F 	0xxxxxxx
   2                             	11                     	 U+0080                  U+07FF 	110xxxxx 	10xxxxxx
   3                       	16                       U+0800                  U+FFFF 	1110xxxx 	10xxxxxx 	10xxxxxx
   4                       	21                  	 U+10000                 U+10FFFF 	11110xxx 	10xxxxxx 	10xxxxxx 	10xxxxxx
*/

/*
  Just a little interesting code snippet:

  To compute (j - 1) % 255, given that j is already in the range 0..254:

  --j;
  j = (u8)(j + (j >> 8));

  To compute (j + 1) % 255, given that j is already in the range 0..254:

  ++j;
  j = (u8)(j + ((j + 1) >> 8));

*/


const char *token ="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-.!%*_+`'~";
const char *separator =" \t()<>@,;:\\\"/[]?={}";
const char *crlf ="\r\n";
const char *missing ="#$&^|\177";


struct preparse  {
  unsigned int code;
  unsigned int subcode;
  unsigned int crcx;
  void * start;
  void * end;
  void *cache;
};

struct sipHeaders {
  char *vector;
  unsigned int code;
};

struct sipHeaders sipHeaders[] = 
  {
    { "Accept\0\0\0\0", 0x45431711},
    { "Accept-Contact\0\0\0\0", 0x473a0d1d},
    { "Accept-Encoding\0\0\0\0", 0x44661a16},
    { "Accept-Language\0\0\0\0", 0x5c6c1e11},
    { "Accept-Resource-Priority\0\0\0\0", 0x79791c04},
    { "Alert-Info\0\0\0\0", 0x1c0c2e53},
    { "Allow\0\0\0\0", 0x4f4c4c16},
    { "Allow-Events\0\0\0\0", 0x4a5d2f53},
    { "Authentication-Info\0\0\0\0", 0x01365246},
    { "Authorization\0\0\0\0", 0x5d545301},
    { "CSeq\0\0\0\0", 0x51455343},
    { "Call-ID\0\0\0\0", 0x4c08086e},
    { "Call-Info\0\0\0\0", 0x0a020821},
    { "Contact\0\0\0\0", 0x541a0c02},
    { "Content-Disposition\0\0\0\0", 0x7d4e5444},
    { "Content-Encoding\0\0\0\0", 0x71170607},
    { "Content-Language\0\0\0\0", 0x7b13011f},
    { "Content-Length\0\0\0\0", 0x3e540c1e},
    { "Content-Type\0\0\0\0", 0x3c4a5852},
    { "Date\0\0\0\0", 0x45544144},
    { "Error-Info\0\0\0\0", 0x011b3051},
    { "Event\0\0\0\0", 0x4e455611},
    { "Expires\0\0\0\0", 0x49031d17},
    { "From\0\0\0\0", 0x4d4f5246},
    { "History-Info\0\0\0\0", 0x364c554e},
    { "Identity\0\0\0\0", 0x17110d1d},
    { "Identity-Info\0\0\0\0", 0x515f447f},
    { "In-Reply-To\0\0\0\0", 0x0b2e4a21},
    { "Join\0\0\0\0", 0x4e494f4a},
    { "MIME-Version\0\0\0\0", 0x59475633},
    { "Max-Forwards\0\0\0\0", 0x294e5c4a},
    { "Min-Expires\0\0\0\0", 0x644d545a},
    { "Min-SE\0\0\0\0", 0x2d4e0c1e},
    { "Organization\0\0\0\0", 0x4e525255},
    { "P-Access-Network-Info\0\0\0\0", 0x494b200b},
    { "P-Asserted-Identity\0\0\0\0", 0x1a293d4b},
    { "P-Associated-URI\0\0\0\0", 0x1715636f},
    { "P-Called-Party-ID\0\0\0\0", 0x1e6a6821},
    { "P-Charging-Function-Addresses\0\0\0\0", 0x29332e14},
    { "P-Charging-Vector\0\0\0\0", 0x187d7b48},
    { "P-DCS-Billing-Info\0\0\0\0", 0x0a062e4e},
    { "P-DCS-LAES\0\0\0\0", 0x02085346},
    { "P-DCS-OSPS\0\0\0\0", 0x100b5353},
    { "P-DCS-Redirect\0\0\0\0", 0x43441d04},
    { "P-DCS-Trace-Party-ID\0\0\0\0", 0x2c4e2f4b},
    { "P-Media-Authorization\0\0\0\0", 0x35583715},
    { "P-Preferred-Identity\0\0\0\0", 0x3a40235a},
    { "P-Visited-Network-ID\0\0\0\0", 0x5f4a3358},
    { "Path\0\0\0\0", 0x48544150},
    { "Priority\0\0\0\0", 0x161d1b02},
    { "Privacy\0\0\0\0", 0x56101111},
    { "Proxy-Authenticate\0\0\0\0", 0x02083b5d},
    { "Proxy-Authorization\0\0\0\0", 0x0b4e225d},
    { "Proxy-Require\0\0\0\0", 0x4f542a1d},
    { "RAck\0\0\0\0", 0x4b434152},
    { "RSeq\0\0\0\0", 0x51455352},
    { "Reason\0\0\0\0", 0x53410b1d},
    { "Record-Route\0\0\0\0", 0x583a544f},
    { "Refer-Sub\0\0\0\0", 0x10156842},
    { "Refer-To\0\0\0\0", 0x0a126800},
    { "Referred-By\0\0\0\0", 0x015a552d},
    { "Reject-Contact\0\0\0\0", 0x47330b1d},
    { "Replaces\0\0\0\0", 0x1f150613},
    { "Reply-To\0\0\0\0", 0x0304680b},
    { "Request-Disposition\0\0\0\0", 0x7c514355},
    { "Require\0\0\0\0", 0x5514171b},
    { "Resource-Priority\0\0\0\0", 0x170b153c},
    { "Retry-After\0\0\0\0", 0x14472d5f},
    { "Route\0\0\0\0", 0x54554f17},
    { "SIP-ETag\0\0\0\0", 0x6a111d16},
    { "SIP-If-Match\0\0\0\0", 0x283e5b5b},
    { "Security-Client\0\0\0\0", 0x450f0169},
    { "Security-Server\0\0\0\0", 0x5e001a7a},
    { "Security-Verify\0\0\0\0", 0x5e0b1c65},
    { "Server\0\0\0\0", 0x56521716},
    { "Service-Route\0\0\0\0", 0x2f42490d},
    { "Session-Expires\0\0\0\0", 0x371e170d},
    { "Subject\0\0\0\0", 0x4a161616},
    { "Subscription-State\0\0\0\0", 0x0c10583d},
    { "Supported\0\0\0\0", 0x15040758},
    { "Target-Dialog\0\0\0\0", 0x4c33541f},
    { "Timestamp\0\0\0\0", 0x080c1d57},
    { "To\0\0\0\0", 0x00004f54},
    { "Unsupported\0\0\0\0", 0x07585b51},
    { "User-Agent\0\0\0\0", 0x17024636},
    { "Via\0\0\0\0", 0x00414956},
    { "WWW-Authenticate\0\0\0\0", 0x69030d10},
    { "Warning\0\0\0\0", 0x4e150f1e},
    { "X-Genesys-CallUUID\0\0\0\0", 0x08024d40}, // manual setting
    {0, 0}};


const char *sipmsg1 = "SIP/2.0 200 OK\r\nTo: sip:446402@ice50.pqa.col.bsf.alcatel.fr;tag=004DC84E-CE15-1E64-91AC-77A21BACAA77-200829\r\nFrom: sip:504072@ice50.pqa.col.bsf.alcatel.fr;tag=8fa5ce9af36bdfc344d15b511deeeceb\r\nCall-ID: 004DC830-CE15-1E64-91AC-77A21BACAA77-5013@ice50.pqa.col.bsf.alcatel.fr\r\nCSeq: 1661102565 INVITE\r\nVia: SIP/2.0/TCP 172.27.163.53;branch=z9hG4bK02a61dd15bc2e7628aa9ef2c39b53287;received=172.27.163.53\r\nContact: <sip:446402@ice50.pqa.col.bsf.alcatel.fr:5260;transport=tcp>\r\nX-Genesys-CallUUID: 00R2T5MJ84F694DCEUH1NB5AES0000D3\r\nAllow: INVITE, ACK, PRACK, CANCEL, BYE, REFER, INFO, UPDATE, MESSAGE, NOTIFY, OPTIONS\r\nUser-Agent: OmniPCX Enterprise R10.0 j1.410.35\r\nP-CAC-ALU: reserved_calling_party\r\nSession-Expires: 1800;refresher=uas\r\nMin-SE: 900\r\nSupported: uui,timer\r\nContent-Type: application/sdp\r\nContent-Length: 230\r\n\r\nv=0\r\no=OXE 1315241030 3 IN IP4 172.27.163.19\r\ns=abs\r\nc=IN IP4 172.27.163.19\r\nt=0 0\r\nm=audio 32616 RTP/AVP 18 96\r\na=sendrecv\r\na=ptime:20\r\na=maxptime:40\r\na=rtpmap:18 G729/8000\r\na=fmtp:18 annexb=no\r\na=rtpmap:96 telephone-event/8000\r\n";
const char *sipmsg3 = "SIP/2.0 200 OK\r\nCall-ID: 004DC830-CE15-1E64-91AC-77A21BACAA77-5013\r\nCSeq: 1661102565 INVITE\r\nContent-Type: application/sdp\r\nContent-Length: 230\r\n\r\nv=0\r\n\r\n";

/* 45431711 17114f4e */ 
 
const char *sipmsg0 = "Accept:\r\nInVyTE \t\t\tsip:callee@callee.com SIP/2.0\r\nVia: SIP/2.0/UDP pc.caller.com;branch=z9hG4bK776asdhds\r\nMax-Forwards: 70\r\nTo: Callee <sip:callee@callee.com>\r\n[\ttab\t]From: Caller <sip:caler@caller.com>;tag=1928301774\r\nCall-ID: a84b4c76e66710\r\nCSeq:\t 314159 INVITE\r\nContact: <sip:caller@pc.caller.com>\r\nContent-Type: application/sdp\r\nContent-Length: 04\r\n\r\nbla";

char buffer [1024];
#define hasNulByte(x) ((x - 0x01010101) & ~x & 0x80808080)
#define SW (sizeof (int) / sizeof (char))

#if 0
int xstrlen (const char *s) {
  const char *p;
  int d;

  p = s - 1;
  do {
    p++;
    if ((((int) p) & (SW - 1)) == 0) {
      do {
	d  = *((int *) p);
	p += SW;
      } while (!hasNulByte (d));
      p -= SW;
    }
  } while (*p != 0);
  return p - s;
}

#endif

#define hasless(x,n) (((x)-~0UL/255*(n))&~(x)&~0UL/255*128)
#define cfour(n)  (~0UL/255*(n))
#define haszero(v)  (((v) - 0x01010101UL) & (~(v) & 0x80808080UL))
#define hasvalue(x,n)				\
  (haszero((x) ^ (~0UL/255 * (n))))


static int trc = 0;

int
prn(char *str, unsigned int v)
{
  unsigned char c0, c1, c2, c3;

  c0 =  (v>>24) & 0xff; 
  c1 =  (v>>16) & 0xff; 
  c2 =  (v>>8) & 0xff;
  c3 =  (v>>0) & 0xff;

  #if 1
  if (!trc)
    return 0;
  #endif
  printf("%08x -- %02x %02x %02x %02x --  %c%c%c%c -- %s\n",v, c3, c2, c1, c0,  
	 isgraph(c3)?c3:'.',  isgraph(c2)?c2:'.', 
	 isgraph(c1)?c1:'.',  isgraph(c0)?c0:'.'
	 , str);
}





#define SWAP_2(x) ( (((x) & 0xff) << 8) | ((unsigned short)(x) >> 8) )
#define SWAP_4(x) ( ((x) << 24) |		\
		    (((x) << 8) & 0x00ff0000) | \
		    (((x) >> 8) & 0x0000ff00) | \
		    ((x) >> 24) )
/* 8-bit CRC with polynomial x^8+x^6+x^3+x^2+1, 0x14D.
   Chosen based on Koopman, et al. (0xA6 in his notation = 0x14D >> 1):
   http://www.ece.cmu.edu/~koopman/roses/dsn04/koopman04_crc_poly_embedded.pdf
*/

static unsigned char crc8_table[] = {
  0x00, 0x3e, 0x7c, 0x42, 0xf8, 0xc6, 0x84, 0xba, 0x95, 0xab, 0xe9, 0xd7,
  0x6d, 0x53, 0x11, 0x2f, 0x4f, 0x71, 0x33, 0x0d, 0xb7, 0x89, 0xcb, 0xf5,
  0xda, 0xe4, 0xa6, 0x98, 0x22, 0x1c, 0x5e, 0x60, 0x9e, 0xa0, 0xe2, 0xdc,
  0x66, 0x58, 0x1a, 0x24, 0x0b, 0x35, 0x77, 0x49, 0xf3, 0xcd, 0x8f, 0xb1,
  0xd1, 0xef, 0xad, 0x93, 0x29, 0x17, 0x55, 0x6b, 0x44, 0x7a, 0x38, 0x06,
  0xbc, 0x82, 0xc0, 0xfe, 0x59, 0x67, 0x25, 0x1b, 0xa1, 0x9f, 0xdd, 0xe3,
  0xcc, 0xf2, 0xb0, 0x8e, 0x34, 0x0a, 0x48, 0x76, 0x16, 0x28, 0x6a, 0x54,
  0xee, 0xd0, 0x92, 0xac, 0x83, 0xbd, 0xff, 0xc1, 0x7b, 0x45, 0x07, 0x39,
  0xc7, 0xf9, 0xbb, 0x85, 0x3f, 0x01, 0x43, 0x7d, 0x52, 0x6c, 0x2e, 0x10,
  0xaa, 0x94, 0xd6, 0xe8, 0x88, 0xb6, 0xf4, 0xca, 0x70, 0x4e, 0x0c, 0x32,
  0x1d, 0x23, 0x61, 0x5f, 0xe5, 0xdb, 0x99, 0xa7, 0xb2, 0x8c, 0xce, 0xf0,
  0x4a, 0x74, 0x36, 0x08, 0x27, 0x19, 0x5b, 0x65, 0xdf, 0xe1, 0xa3, 0x9d,
  0xfd, 0xc3, 0x81, 0xbf, 0x05, 0x3b, 0x79, 0x47, 0x68, 0x56, 0x14, 0x2a,
  0x90, 0xae, 0xec, 0xd2, 0x2c, 0x12, 0x50, 0x6e, 0xd4, 0xea, 0xa8, 0x96,
  0xb9, 0x87, 0xc5, 0xfb, 0x41, 0x7f, 0x3d, 0x03, 0x63, 0x5d, 0x1f, 0x21,
  0x9b, 0xa5, 0xe7, 0xd9, 0xf6, 0xc8, 0x8a, 0xb4, 0x0e, 0x30, 0x72, 0x4c,
  0xeb, 0xd5, 0x97, 0xa9, 0x13, 0x2d, 0x6f, 0x51, 0x7e, 0x40, 0x02, 0x3c,
  0x86, 0xb8, 0xfa, 0xc4, 0xa4, 0x9a, 0xd8, 0xe6, 0x5c, 0x62, 0x20, 0x1e,
  0x31, 0x0f, 0x4d, 0x73, 0xc9, 0xf7, 0xb5, 0x8b, 0x75, 0x4b, 0x09, 0x37,
  0x8d, 0xb3, 0xf1, 0xcf, 0xe0, 0xde, 0x9c, 0xa2, 0x18, 0x26, 0x64, 0x5a,
  0x3a, 0x04, 0x46, 0x78, 0xc2, 0xfc, 0xbe, 0x80, 0xaf, 0x91, 0xd3, 0xed,
  0x57, 0x69, 0x2b, 0x15};

unsigned int crcx(unsigned int crx, unsigned int x)
{
  unsigned char c0, c1, c2, c3;
  unsigned char crx0, crx1, crx2, crx3;
  c0 =  (x>>24) & 0xff; 
  c1 =  (x>>16) & 0xff; 
  c2 =  (x>>8) & 0xff;
  c3 =  (x>>0) & 0xff;
  crx0 =  (crx>>24) & 0xff; 
  crx1 =  (crx>>16) & 0xff; 
  crx2 =  (crx>>8) & 0xff;
  crx3 =  (crx>>0) & 0xff;
  crx0 =  crc8_table[crx0 ^ c0];
  crx1 =  crc8_table[crx1 ^ c1];
  crx2 =  crc8_table[crx2 ^ c2];
  crx3 =  crc8_table[crx3 ^ c3];
    
  return (crx0 << 24) | (crx1 << 16) | (crx2 << 8) | (crx3) ;
}


unsigned int crcxc0c1c2(unsigned int crx, unsigned int x)
{
  unsigned char c0, c1, c2, c3;
  unsigned char crx0, crx1, crx2, crx3;
  prn("crcxc0c1c2", x);
  c0 =  (x>>24) & 0xff; 
  c1 =  (x>>16) & 0xff; 
  c2 =  (x>>8) & 0xff;
  c3 =  (x>>0) & 0xff;
  crx0 =  (crx>>24) & 0xff; 
  crx1 =  (crx>>16) & 0xff; 
  crx2 =  (crx>>8) & 0xff;
  crx3 =  (crx>>0) & 0xff;
  crx0 =  crc8_table[crx0 ^ c0];
  crx1 =  crc8_table[crx1 ^ c1];
  crx2 =  crc8_table[crx2 ^ c2];
  //crx3 =  crc8_table[crx3 ^ c3];
  return (crx0 << 24) | (crx1 << 16) | (crx2 << 8) | (crx3) ;
 
}

unsigned int crcxc1c2c3(unsigned int crx, unsigned int x)
{
  unsigned char c0, c1, c2, c3;
  unsigned char crx0, crx1, crx2, crx3;
  prn("crcxc1c2c3", x);
  c0 =  (x>>24) & 0xff; 
  c1 =  (x>>16) & 0xff; 
  c2 =  (x>>8) & 0xff;
  c3 =  (x>>0) & 0xff;
  crx0 =  (crx>>24) & 0xff; 
  crx1 =  (crx>>16) & 0xff; 
  crx2 =  (crx>>8) & 0xff;
  crx3 =  (crx>>0) & 0xff;
  //crx0 =  crc8_table[crx0 ^ c0];
  crx1 =  crc8_table[crx1 ^ c1];
  crx2 =  crc8_table[crx2 ^ c2];
  crx3 =  crc8_table[crx3 ^ c3];
  return (crx0 << 24) | (crx1 << 16) | (crx2 << 8) | (crx3) ;
 
}
unsigned int crcxc0c1(unsigned int crx, unsigned int x)
{
  unsigned char c0, c1, c2, c3;
  unsigned char crx0, crx1, crx2, crx3;
  c0 =  (x>>24) & 0xff; 
  c1 =  (x>>16) & 0xff; 
  c2 =  (x>>8) & 0xff;
  c3 =  (x>>0) & 0xff;
  crx0 =  (crx>>24) & 0xff; 
  crx1 =  (crx>>16) & 0xff; 
  crx2 =  (crx>>8) & 0xff;
  crx3 =  (crx>>0) & 0xff;
  
  
  crx2 =  crc8_table[crx2 ^ c2];
  crx3 =  crc8_table[crx3 ^ c3];
  return (crx0 << 24) | (crx1 << 16) | (crx2 << 8) | (crx3) ;
 
}
unsigned int crcxc2c3(unsigned int crx, unsigned int x)
{
  unsigned char c0, c1, c2, c3;
  unsigned char crx0, crx1, crx2, crx3;
  c0 =  (x>>24) & 0xff; 
  c1 =  (x>>16) & 0xff; 
  c2 =  (x>>8) & 0xff;
  c3 =  (x>>0) & 0xff;
  crx0 =  (crx>>24) & 0xff; 
  crx1 =  (crx>>16) & 0xff; 
  crx2 =  (crx>>8) & 0xff;
  crx3 =  (crx>>0) & 0xff;
  
  
  crx2 =  crc8_table[crx2 ^ c2];
  crx3 =  crc8_table[crx3 ^ c3];
  return (crx0 << 24) | (crx1 << 16) | (crx2 << 8) | (crx3) ;
 
}
unsigned int crcxc0(unsigned int crx, unsigned int x)
{
  unsigned char c0, c1, c2, c3;
  unsigned char crx0, crx1, crx2, crx3;
  c0 =  (x>>24) & 0xff; 
  c1 =  (x>>16) & 0xff; 
  c2 =  (x>>8) & 0xff;
  c3 =  (x>>0) & 0xff;
  crx0 =  (crx>>24) & 0xff; 
  crx1 =  (crx>>16) & 0xff; 
  crx2 =  (crx>>8) & 0xff;
  crx3 =  (crx>>0) & 0xff;
  
  
  
  crx3 =  crc8_table[crx3 ^ c3];
  return (crx0 << 24) | (crx1 << 16) | (crx2 << 8) | (crx3) ;
 
}

unsigned int crcxc0c1blah(unsigned int crx, unsigned int x)
{
  unsigned char c0, c1;
  unsigned char crx0, crx1, crx2, crx3;
  c0 =  (x>>24) & 0xff; 
  c1 =  (x>>16) & 0xff; 

  crx0 =  (crx>>24) & 0xff; 
  crx1 =  (crx>>16) & 0xff; 
  crx2 =  (crx>>8) & 0xff;
  crx3 =  (crx>>0) & 0xff;
  crx0 =  crc8_table[crx0 ^ c0];
  crx1 =  crc8_table[crx1 ^ c1];

  
  return (crx0 << 24) | (crx1 << 16) | (crx2 << 8) | (crx3) ;
 
}


unsigned int crcxc3c2(unsigned int crx, unsigned int x)
{
  unsigned char c0, c1, c2,c3;
  unsigned char crx0, crx1, crx2, crx3;
  c0 =  (x>>24) & 0xff; 
  c1 =  (x>>16) & 0xff; 
  c2 =  (x>>8) & 0xff;
  c3 =  (x>>0) & 0xff;
  crx0 =  (crx>>24) & 0xff; 
  crx1 =  (crx>>16) & 0xff; 
  crx2 =  (crx>>8) & 0xff;
  crx3 =  (crx>>0) & 0xff;
  crx3 =  crc8_table[crx3 ^ c3];
  crx2 =  crc8_table[crx2 ^ c2];

  
  return (crx0 << 24) | (crx1 << 16) | (crx2 << 8) | (crx3) ;
 
}
unsigned int crcxc0blah(unsigned int crx, unsigned int x)
{
  unsigned char c0;
  unsigned char crx0, crx1, crx2, crx3;
  c0 =  (x>>24) & 0xff; 

  crx0 =  (crx>>24) & 0xff; 
  crx1 =  (crx>>16) & 0xff; 
  crx2 =  (crx>>8) & 0xff;
  crx3 =  (crx>>0) & 0xff;
  crx0 =  crc8_table[crx0 ^ c0];
 

  
  return (crx0 << 24) | (crx1 << 16) | (crx2 << 8) | (crx3) ;
 
}

unsigned int crcxc3(unsigned int crx, unsigned int x)
{
  unsigned char c3;
  unsigned char crx0, crx1, crx2, crx3;
  c3 =   (x>>24) & 0xff; 

  crx0 =  (crx>>24) & 0xff; 
  crx1 =  (crx>>16) & 0xff; 
  crx2 =  (crx>>8) & 0xff;
  crx3 =  (crx>>0) & 0xff;
  crx3 =  crc8_table[crx3 ^ c3];
 
  prn("crcx3", c3 );
  
  return (crx0 << 24) | (crx1 << 16) | (crx2 << 8) | (crx3) ;
 
}


unsigned int
crcstr(unsigned char *data, size_t len)
{
  unsigned int *end;
  unsigned int *ptr, crc;
  
  ptr = (unsigned int *) data;
  
  if (len == 0)
    return 0;
  
  crc = 0;
  end = (unsigned int *)(data + len);
  end = end -1;
  do {
    //prn("crc", crc);
    prn("*ptr", *ptr);
    crc = crcx(crc, *ptr++);
    prn("crc", crc);
    len -= 4;
  } while (ptr <= end);


  prn("remainder ptr", *ptr);
  switch (len)
    {
    case 0:
      prn("crc-0", crc);
      return crc;
      break;
    case 1:
      crc = crcxc0(crc, *ptr);
      prn("crc-1", crc);
      return crc;
      break;
    case 2:
      prn("crc-2", crc);
      crc = crcxc3c2(crc, *ptr);
      prn("crc-2", crc);
      return crc;
      break;

    case 3:
      prn("crc-3", crc);
      crc = crcxc1c2c3(crc, *ptr);
      prn("crc-3", crc);
      return crc;
      break;
    default:
      return 0;
    }

  return 0;
}
unsigned crc8(unsigned crc, unsigned char *data, size_t len)
{
  unsigned char *end;

  if (len == 0)
    return crc;
  crc = 0;
  end = data + len;
  do {
    crc = crc8_table[crc ^ *data++];
  } while (data < end);
  return crc ^ 0xff;
}

#if 0
#include <stddef.h>

/* 8-bit CRC with polynomial x^8+x^6+x^3+x^2+1, 0x14D.
   Chosen based on Koopman, et al. (0xA6 in his notation = 0x14D >> 1):
   http://www.ece.cmu.edu/~koopman/roses/dsn04/koopman04_crc_poly_embedded.pdf
*/

static unsigned char crc8_table[] = {
  0x00, 0x3e, 0x7c, 0x42, 0xf8, 0xc6, 0x84, 0xba, 0x95, 0xab, 0xe9, 0xd7,
  0x6d, 0x53, 0x11, 0x2f, 0x4f, 0x71, 0x33, 0x0d, 0xb7, 0x89, 0xcb, 0xf5,
  0xda, 0xe4, 0xa6, 0x98, 0x22, 0x1c, 0x5e, 0x60, 0x9e, 0xa0, 0xe2, 0xdc,
  0x66, 0x58, 0x1a, 0x24, 0x0b, 0x35, 0x77, 0x49, 0xf3, 0xcd, 0x8f, 0xb1,
  0xd1, 0xef, 0xad, 0x93, 0x29, 0x17, 0x55, 0x6b, 0x44, 0x7a, 0x38, 0x06,
  0xbc, 0x82, 0xc0, 0xfe, 0x59, 0x67, 0x25, 0x1b, 0xa1, 0x9f, 0xdd, 0xe3,
  0xcc, 0xf2, 0xb0, 0x8e, 0x34, 0x0a, 0x48, 0x76, 0x16, 0x28, 0x6a, 0x54,
  0xee, 0xd0, 0x92, 0xac, 0x83, 0xbd, 0xff, 0xc1, 0x7b, 0x45, 0x07, 0x39,
  0xc7, 0xf9, 0xbb, 0x85, 0x3f, 0x01, 0x43, 0x7d, 0x52, 0x6c, 0x2e, 0x10,
  0xaa, 0x94, 0xd6, 0xe8, 0x88, 0xb6, 0xf4, 0xca, 0x70, 0x4e, 0x0c, 0x32,
  0x1d, 0x23, 0x61, 0x5f, 0xe5, 0xdb, 0x99, 0xa7, 0xb2, 0x8c, 0xce, 0xf0,
  0x4a, 0x74, 0x36, 0x08, 0x27, 0x19, 0x5b, 0x65, 0xdf, 0xe1, 0xa3, 0x9d,
  0xfd, 0xc3, 0x81, 0xbf, 0x05, 0x3b, 0x79, 0x47, 0x68, 0x56, 0x14, 0x2a,
  0x90, 0xae, 0xec, 0xd2, 0x2c, 0x12, 0x50, 0x6e, 0xd4, 0xea, 0xa8, 0x96,
  0xb9, 0x87, 0xc5, 0xfb, 0x41, 0x7f, 0x3d, 0x03, 0x63, 0x5d, 0x1f, 0x21,
  0x9b, 0xa5, 0xe7, 0xd9, 0xf6, 0xc8, 0x8a, 0xb4, 0x0e, 0x30, 0x72, 0x4c,
  0xeb, 0xd5, 0x97, 0xa9, 0x13, 0x2d, 0x6f, 0x51, 0x7e, 0x40, 0x02, 0x3c,
  0x86, 0xb8, 0xfa, 0xc4, 0xa4, 0x9a, 0xd8, 0xe6, 0x5c, 0x62, 0x20, 0x1e,
  0x31, 0x0f, 0x4d, 0x73, 0xc9, 0xf7, 0xb5, 0x8b, 0x75, 0x4b, 0x09, 0x37,
  0x8d, 0xb3, 0xf1, 0xcf, 0xe0, 0xde, 0x9c, 0xa2, 0x18, 0x26, 0x64, 0x5a,
  0x3a, 0x04, 0x46, 0x78, 0xc2, 0xfc, 0xbe, 0x80, 0xaf, 0x91, 0xd3, 0xed,
  0x57, 0x69, 0x2b, 0x15};

unsigned crc8(unsigned crc, unsigned char *data, size_t len)
{
  unsigned char *end;

  if (len == 0)
    return crc;
  crc ^= 0xff;
  end = data + len;
  do {
    crc = crc8_table[crc ^ *data++];
  } while (data < end);
  return crc ^ 0xff;
}
int datalen;
unsigned char crc = crc_init;
unsigned char data[datalen];
int i, j;
unsigned char gpoly = 0xEA;
for (i=0; i<datalen; i++) {
  /
  *
    begin core algorithm
    *
    /
    for (j=0; j<8; j++) {
      if (lsb(data) ˆ lsb(crc)) {
	crc = (crc << 1) ˆ (gpoly_brev);
      } else {
	crc = (crc << 1);
      }
      data[i] <<= 1;
    }
  /
    *
      end core algorithm
      *
      /
      }
#endif
const unsigned char polynome = 0xEA;

#define rol32(word, shift)  ((word << shift) | (word >> (32 - shift)))
#define ror32(word, shift)  ((word >> shift) | (word << (32 - shift)))


static char *unknown = "Unknown";
char *
getHeader(unsigned int cx)
{
  int i;

  for (i = 0; sipHeaders[i].vector; i++)
    {
      if (sipHeaders[i].code ==  cx) 
	{
	  return  sipHeaders[i].vector;
	}
    }
  return unknown;
}

int
findHeader(unsigned int cx, unsigned int ocx)
{
  int i;
  unsigned int ncx =  cx,  v =  cx;

#if 0
  prn("cx", cx);
  prn("rol32(cx, 8)", rol32(cx, 8));
  prn("rol32(cx, 16)", rol32(cx, 16));
  prn("rol32(cx, 24)", rol32(cx, 24));
  prn("ror32(cx, 8)", ror32(cx, 8));
  prn("ror32(cx, 16)", ror32(cx, 16));
  prn("ror32(cx, 24)", ror32(cx, 24));
  prn("SWAP_4(cx)", SWAP_4(cx));

  if (ocx ==  6) cx =  ror32(cx, 8);
  if (ocx ==  5) {cx =  ror32(cx, 16); }
  if (ocx ==  4) {cx =  ror32(cx, 24); }
#endif
  printf(" %d: %08x =>%08x ",  ocx,  ncx,  cx);    
  for (i = 0; sipHeaders[i].vector; i++)
    {
      if (sipHeaders[i].code ==  cx) 
	{
	  printf(" matched !%d / %s / 0x%08x\n", i, sipHeaders[i].vector,  cx);
	  return 1;
	}
    }
  printf(" unmatched ! 0x%08x\n", cx);
  return 0;
}


int 
crlf_trigger(const char *msg, int sz, struct preparse preparse[], int psz)
{
  int cnt = sz/4 + 1;
  unsigned int *ptr= (int *)msg;
  unsigned int x,y,z, realx,  cx, ocx, presume_mask = 0, crx;
  int scan_semicolon =  0;
  int ix = 0;

  //printf("%s",  msg);
  

  cx = 0; crx=0;
  
  preparse[ix].start = ptr;
  while(cnt--)
    {
      x = *ptr++;
      realx = x;
      y = 0x7f7f7f7f;
      z = y;
      // prn("Alpha x", x);
      // prn("Alpha y, z", y);
      y = y & x;
      // prn("Alpha y = y & x", y);
      y = y + 0x05050505;
      // prn("Alpha y = y + 0x05050505", y);
      y = y & z;
      // prn("Alpha y = y & z", y);
      y = y + 0x1a1a1a1a;
      // prn("Alpha y = y + 0x1a1a1a1a", y);
      y = y >> 2;
      // prn("Alpha y = y >> 2 ", y);
      y = y &  0x20202020;
      // prn("Alpha y = y &  0x20202020", y);
      x = x - y;
      // prn("Alpha x = x - y", x);
      if (hasvalue(x, 9))
        {
          // prn("tab", x);
          z = 0x20202020;   /* blanks */
	  // prn("z", z);
          y = x ^ 0x09090909;
	  // prn("y = x ^ 0x09090909", y);
          y = y & 0x7f7f7f7f;
	  // prn("y = y & 0x7f7f7f7f", y);
          y = y + 0x7f7f7f7f;
	  // prn("y = y + 0x7f7f7f7f", y);
          y = y | x;
	  // prn("y = y | x", y);
          y = y & 0x80808080;
	  // prn("y & 0x80808080", y);
          x = x ^ z;
	  // prn("x = x ^ z", x);
          y = y >> 7;
	  // prn("y = y >> 7", y);
          y = y + 0x7f7f7f7f;
	  // prn("y = y + 0x7f7f7f7f", y);
          y = y ^ 0x7f7f7f7f;
	  // prn("y = y ^ 0x7f7f7f7f", y);
          x = x & y;
	  // prn("x = x & y", x);
          z = x ^ z;
	  // prn("z = x ^ z",  z);

	  x =  z;
	  //prn("tab -> space",  x);
        }

      if (scan_semicolon &&  hasvalue(x, 58))
	{
	  prn("scan : x", x);
	  y =  hasvalue(x, 58);
	 
	  y =  (y - 1) & 0x80808080;
	  // prn("y =  (y - 1) & 0x80808080", y);
	  y = y >> 7;
	  // prn("y = y >> 7", y);
	  y = y + 0x7f7f7f7f;
	  // prn("y = y + 0x7f7f7f7f", y);
          y = y ^ 0x7f7f7f7f;
	  // prn("y = y ^ 0x7f7f7f7f", y);
	  //prn(": mask",  y);
	  //prn("semi colon cxA", cx);

          x = (x &  y);
          //prn("xlf:", x);
#if 1
          y =  hasvalue(x, 10);
          if (y)
            {
              //prn("ylf:", y);
              y = y >> 7;
              z =  y;
              //prn("z", z);
              // prn("y = y >> 7", y);
              y = y + 0x7f7f7f7f;
              // prn("y = y + 0x7f7f7f7f", y);
              y = y ^ 0x7f7f7f7f;
              // prn("y = y ^ 0x7f7f7f7f", y);
              y =  ~y;
              prn("scan : crlf",  y);
              cx = cx ^ (x &  y);
              if (y == 0xffffff00)
                 {
                  crx = crcxc0c1c2(crx,  realx);
                  preparse[ix].end = ptr;
                  preparse[ix].end += 3;
                }
                
            }
          else
            {
              cx = cx ^ x;
              crx = crcx(crx,  realx);
            }
          prn("scan found cx", cx); 
          prn("scan current crcx:", crx);

  #endif

          if (ocx ==  6) cx =  ror32(cx, 8);
	  if (ocx ==  3) cx =  ror32(cx, 8);
          if (ocx ==  5) {cx =  ror32(cx, 16); }
          if (ocx ==  4) {cx =  ror32(cx, 24); }
          
          preparse[ix].code = cx;
          preparse[ix].subcode  = ocx;
          scan_semicolon =  0;
	  // cx = 0;
	  // prn("cx = 0", cx);
	  // Note !  what to do if crlf??
	}
      else if (hasless(x, 15))
        {
	  prn("treat crlf", x);
        
          
          
	  y =  ((x)-~0UL/255*(15));
	  
	  // prn("crlf y =  ((x)-~0UL/255*(15))", y);
	  y =  (y) & 0x80808080;
	  // prn("y =  (y) & 0x80808080", y - 1);
	
	  y = y >> 7;
	  z =  y;
	  //prn("z", z);
	  // prn("y = y >> 7", y);
	  y = y + 0x7f7f7f7f;
	  // prn("y = y + 0x7f7f7f7f", y);
          y = y ^ 0x7f7f7f7f;
	  // prn("y = y ^ 0x7f7f7f7f", y);
	  y =  ~y;
	  prn("crlf mask",  y);
	  prn("crc-x", crx);

	  switch (y)
	    {
	    case 0x00000000 :
              if (preparse[ix].end == 0)
                {
                  preparse[ix].end = ptr;
                  preparse[ix].end -= 4;
                }
              preparse[ix].crcx = crx;
              prn("ocx", ocx);
              if (ocx != 1)
                {
                  ix= ix +1;
                  preparse[ix].start = ptr;
                  preparse[ix].subcode  = ocx;
                }
	      crx = cx =  0;
	      prn("cx =1a", cx);
	      ocx =  0;
              trc = 1;
	      break;
            case 0x000000ff :
              preparse[ix].end = ptr;
              preparse[ix].end -= 3;
              crx = crcxc0(crx ,  realx);
              preparse[ix].crcx = crx;
              prn("ocx", ocx);
              ix= ix +1;
              preparse[ix].start = ptr;
              preparse[ix].subcode  = ocx;
              crx = cx =  0;
	      prn("cx =1b", cx);
	      ocx =  1;
              trc = 0;
	      break;
	    case 0x0000ffff :
	      //cx =  (x &  y);
              crx = crcxc0c1(crx ,  realx);
              prn("crc-x=2", crx);
              preparse[ix].crcx = crx;
	      crx = cx=0;
	      prn("cx =2", cx); //  one line cx
	      preparse[ix].end = ptr;
              preparse[ix].end -= 2;
              ix = ix +1;
              preparse[ix].start = ptr;
              //  preparse[ix].start += 2;
              ocx = 2;
              trc = 0;
	      break;

	    case 0x00ffffff :
	      trc=0;
              crx = crcxc1c2c3(crx ,  realx);
              preparse[ix].crcx = crx;
              prn("crc-x", crx);
	      crx = cx=0;
	      prn("cx =3", cx);
              preparse[ix].end = ptr;
              preparse[ix].end -= 1;
              
              ix = ix +1;
              preparse[ix].start = ptr;
              preparse[ix].start += 1;
	      ocx = 3;

	      break;
	    case 0xff0000ff :
              trc = 0;
              
	      cx =  (x &  0xff000000);
              prn("4-0xff0000ff", realx);
              crx = crcxc0(crx ,  realx);
              prn("crc-4o", crx);
              preparse[ix].crcx = crx;
              preparse[ix].end = ptr;
              preparse[ix].end -= 3;
              ix = ix +1;
              preparse[ix].start = ptr ;
              preparse[ix].start -= 1;
              crx = crcxc0blah(0 ,  realx);
              prn("4-0xff0000ff crx", realx);
              prn("crc-4n", crx);
	      
	      ocx = 4;
              
	      break;
	    case 0xffff0000 :
	      cx =  (x &  y);
              
	      prn("cx =5", cx);
              preparse[ix].end = ptr;
              preparse[ix].end -= 4;
              preparse[ix].crcx = crx;
              ix = ix +1;
              preparse[ix].start = ptr;
              preparse[ix].start -= 2;

              crx = crcxc0c1blah(0 ,  realx);
              trc = 0;


              ocx =  5;
	      break;
	    case 0xffffff00 :
              preparse[ix].end = ptr;
              preparse[ix].crcx = crx;
              preparse[ix].end += 3;
	      cx = (x &  y);
              crx = crcxc0c1c2(0 ,  realx);
              
	      ocx =  6;
	      prn("cx =6", cx);
              trc = 0;
              /*
		ix = ix +1;
              
		preparse[ix].start = ptr;
		preparse[ix].start -= 3; */
	      break;
	    default:
              trc = 0;
              ;
	     
	    }
          prn("crlf switch", y);
          
          scan_semicolon =  1;
          
          
          
          prn("z |  presume_mask",  z |  presume_mask);
	  if ((z |  presume_mask) ==  0x01010101)
	    {
              prn("codebody", ix);
              preparse[ix].end  = ptr;
              
              preparse[ix].code  = 0xc0deb0d1;
              printf("%04d: [%p/%p]%08x/%d\n",ix,preparse[ix].start,preparse[ix].end, preparse[ix].code, preparse[ix].subcode);
              return ix+1;
	    }
          prn("z ",  z );
	  presume_mask =  z;
	}
      else 
	{
	  prn("real-x", realx);
          //prn("crc-x-fulla", crx);
	  cx =  cx ^ x;
          crx = crcx(crx,  realx);
          prn("crc-x-plain", crx);
	  presume_mask =  0;
	}

    }

  return ix;
} 


int
prncrx(int i,struct preparse pre[], char *str)
{
  unsigned char c0, c1, c2, c3;
  unsigned char co0, co1, co2, co3;
  unsigned int v , vo, ocx;
  char * header;
  v = pre[i].crcx;
  ocx = pre[i].subcode;
  if (ocx ==  6) v =  ror32(v, 8);
  if (ocx ==  5) {v =  ror32(v, 16); }
  if (ocx ==  4) {v =  ror32(v, 24); }
  if (ocx ==  3) {v =  ror32(v, 8); }
  if (ocx == 15)
    trc = 1;
  else trc = 0;
  vo = crcstr(str, strlen(str));
  header = getHeader( pre[i].code);
  
  c0 =  (v>>24) & 0xff; 
  c1 =  (v>>16) & 0xff; 
  c2 =  (v>>8) & 0xff;
  c3 =  (v>>0) & 0xff;


  co0 =  (vo>>24) & 0xff; 
  co1 =  (vo>>16) & 0xff; 
  co2 =  (vo>>8) & 0xff;
  co3 =  (vo>>0) & 0xff;
  if (header != unknown)
    {

      printf("%04d: {\033[4;40m\033[32m%s\033[m}\n\t[%p/%p] \t  %s%02x%s%s%02x%s%s%02x%s%s%02x%s %08x/%d ",i, str,pre[i].start,pre[i].end,

             (c0 == co0)?"\033[32m":"\033[31m", c0,"\033[0m",
             (c1 == co1)?"\033[32m":"\033[31m", c1,"\033[0m",
             (c2 == co2)?"\033[32m":"\033[31m", c2,"\033[0m",
             (c3 == co3)?"\033[32m":"\033[31m", c3,"\033[0m",
             pre[i].code, pre[i].subcode 
             );
      
    }
  else
    {
      if (pre[i].code == 0xc0deb0d1)
        str = "CodeBody";

      printf("%04d: {\033[4;40m\033[31m%s\033[m}[%p/%p] \t  %s%02x%s%s%02x%s%s%02x%s%s%02x%s %08x/%d ",i, str,pre[i].start,pre[i].end,

             (c0 == co0)?"\033[32m":"\033[31m", c0,"\033[0m",
             (c1 == co1)?"\033[32m":"\033[31m", c1,"\033[0m",
             (c2 == co2)?"\033[32m":"\033[31m", c2,"\033[0m",
             (c3 == co3)?"\033[32m":"\033[31m", c3,"\033[0m",
             pre[i].code, pre[i].subcode 
             );
    }
  if (v != vo) printf("%02x%02x%02x%02x\n", co0, co1,co2,co3);
  else printf("\n");
  if (pre[i].code != 0xc0deb0d1)
    hexdump(pre[i].start, (int)(pre[i].end -  pre[i].start));
}

unsigned char sipmsgA[] = { 0x00,0x1d,0x09,0x14,0xe5,0xa7,0x00,0x1b,0x77,0x80,0xd3,0x9c,0x08,0x00,0x45,0x00,
			    0x04,0x29,0x20,0x0e,0x00,0x00,0x80,0x11,0xca,0xc6,0xc0,0xa8,0x65,0x9d,0xc0,0xa8,
			    0x65,0x01,0xf7,0xb6,0x13,0xc4,0x04,0x15,0xc1,0xf0,0x49,0x4e,0x56,0x49,0x54,0x45,
			    0x20,0x73,0x69,0x70,0x3a,0x31,0x30,0x31,0x31,0x40,0x31,0x39,0x32,0x2e,0x31,0x36,
			    0x38,0x2e,0x31,0x30,0x31,0x2e,0x31,0x20,0x53,0x49,0x50,0x2f,0x32,0x2e,0x30,0x0d,
			    0x0a,0x56,0x69,0x61,0x3a,0x20,0x53,0x49,0x50,0x2f,0x32,0x2e,0x30,0x2f,0x55,0x44,
			    0x50,0x20,0x31,0x39,0x32,0x2e,0x31,0x36,0x38,0x2e,0x31,0x30,0x31,0x2e,0x31,0x35,
			    0x37,0x3a,0x36,0x33,0x34,0x31,0x34,0x3b,0x62,0x72,0x61,0x6e,0x63,0x68,0x3d,0x7a,
			    0x39,0x68,0x47,0x34,0x62,0x4b,0x2d,0x64,0x38,0x37,0x35,0x34,0x33,0x2d,0x61,0x34,
			    0x33,0x36,0x61,0x34,0x34,0x66,0x63,0x35,0x31,0x32,0x33,0x34,0x32,0x38,0x2d,0x31,
			    0x2d,0x2d,0x64,0x38,0x37,0x35,0x34,0x33,0x2d,0x3b,0x72,0x70,0x6f,0x72,0x74,0x0d,
			    0x0a,0x4d,0x61,0x78,0x2d,0x46,0x6f,0x72,0x77,0x61,0x72,0x64,0x73,0x3a,0x20,0x37,
			    0x30,0x0d,0x0a,0x43,0x6f,0x6e,0x74,0x61,0x63,0x74,0x3a,0x20,0x3c,0x73,0x69,0x70,
			    0x3a,0x31,0x30,0x31,0x30,0x40,0x31,0x39,0x32,0x2e,0x31,0x36,0x38,0x2e,0x31,0x30,
			    0x31,0x2e,0x31,0x35,0x37,0x3a,0x36,0x33,0x34,0x31,0x34,0x3e,0x0d,0x0a,0x54,0x6f,
			    0x3a,0x20,0x22,0x31,0x30,0x31,0x31,0x22,0x3c,0x73,0x69,0x70,0x3a,0x31,0x30,0x31,
			    0x31,0x40,0x31,0x39,0x32,0x2e,0x31,0x36,0x38,0x2e,0x31,0x30,0x31,0x2e,0x31,0x3e,
			    0x0d,0x0a,0x46,0x72,0x6f,0x6d,0x3a,0x20,0x22,0x54,0x65,0x73,0x74,0x22,0x3c,0x73,
			    0x69,0x70,0x3a,0x31,0x30,0x31,0x30,0x40,0x31,0x39,0x32,0x2e,0x31,0x36,0x38,0x2e,
			    0x31,0x30,0x31,0x2e,0x31,0x3e,0x3b,0x74,0x61,0x67,0x3d,0x30,0x35,0x31,0x65,0x38,
			    0x34,0x33,0x64,0x0d,0x0a,0x43,0x61,0x6c,0x6c,0x2d,0x49,0x44,0x3a,0x20,0x5a,0x6d,
			    0x51,0x77,0x5a,0x54,0x49,0x77,0x5a,0x54,0x45,0x30,0x59,0x32,0x4d,0x79,0x59,0x7a,
			    0x6b,0x77,0x4e,0x7a,0x6c,0x6d,0x4e,0x44,0x6c,0x69,0x4d,0x32,0x4a,0x6a,0x4f,0x54,
			    0x6b,0x79,0x4e,0x32,0x46,0x6a,0x4e,0x57,0x55,0x2e,0x0d,0x0a,0x43,0x53,0x65,0x71,
			    0x3a,0x20,0x32,0x20,0x49,0x4e,0x56,0x49,0x54,0x45,0x0d,0x0a,0x41,0x6c,0x6c,0x6f,
			    0x77,0x3a,0x20,0x49,0x4e,0x56,0x49,0x54,0x45,0x2c,0x20,0x41,0x43,0x4b,0x2c,0x20,
			    0x43,0x41,0x4e,0x43,0x45,0x4c,0x2c,0x20,0x4f,0x50,0x54,0x49,0x4f,0x4e,0x53,0x2c,
			    0x20,0x42,0x59,0x45,0x2c,0x20,0x52,0x45,0x46,0x45,0x52,0x2c,0x20,0x4e,0x4f,0x54,
			    0x49,0x46,0x59,0x2c,0x20,0x4d,0x45,0x53,0x53,0x41,0x47,0x45,0x2c,0x20,0x53,0x55,
			    0x42,0x53,0x43,0x52,0x49,0x42,0x45,0x2c,0x20,0x49,0x4e,0x46,0x4f,0x0d,0x0a,0x43,
			    0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x54,0x79,0x70,0x65,0x3a,0x20,0x61,0x70,0x70,
			    0x6c,0x69,0x63,0x61,0x74,0x69,0x6f,0x6e,0x2f,0x73,0x64,0x70,0x0d,0x0a,0x50,0x72,
			    0x6f,0x78,0x79,0x2d,0x41,0x75,0x74,0x68,0x6f,0x72,0x69,0x7a,0x61,0x74,0x69,0x6f,
			    0x6e,0x3a,0x20,0x44,0x69,0x67,0x65,0x73,0x74,0x20,0x75,0x73,0x65,0x72,0x6e,0x61,
			    0x6d,0x65,0x3d,0x22,0x31,0x30,0x31,0x30,0x22,0x2c,0x72,0x65,0x61,0x6c,0x6d,0x3d,
			    0x22,0x61,0x73,0x74,0x65,0x72,0x69,0x73,0x6b,0x22,0x2c,0x6e,0x6f,0x6e,0x63,0x65,
			    0x3d,0x22,0x37,0x36,0x65,0x34,0x63,0x30,0x33,0x32,0x22,0x2c,0x75,0x72,0x69,0x3d,
			    0x22,0x73,0x69,0x70,0x3a,0x31,0x30,0x31,0x31,0x40,0x31,0x39,0x32,0x2e,0x31,0x36,
			    0x38,0x2e,0x31,0x30,0x31,0x2e,0x31,0x22,0x2c,0x72,0x65,0x73,0x70,0x6f,0x6e,0x73,
			    0x65,0x3d,0x22,0x36,0x38,0x66,0x64,0x36,0x31,0x31,0x64,0x62,0x65,0x61,0x34,0x30,
			    0x31,0x63,0x37,0x66,0x63,0x33,0x63,0x65,0x63,0x34,0x63,0x31,0x64,0x37,0x63,0x63,
			    0x31,0x38,0x32,0x22,0x2c,0x61,0x6c,0x67,0x6f,0x72,0x69,0x74,0x68,0x6d,0x3d,0x4d,
			    0x44,0x35,0x0d,0x0a,0x55,0x73,0x65,0x72,0x2d,0x41,0x67,0x65,0x6e,0x74,0x3a,0x20,
			    0x58,0x2d,0x4c,0x69,0x74,0x65,0x20,0x72,0x65,0x6c,0x65,0x61,0x73,0x65,0x20,0x31,
			    0x30,0x30,0x36,0x65,0x20,0x73,0x74,0x61,0x6d,0x70,0x20,0x33,0x34,0x30,0x32,0x35,
			    0x0d,0x0a,0x43,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x4c,0x65,0x6e,0x67,0x74,0x68,
			    0x3a,0x20,0x33,0x33,0x34,0x0d,0x0a,0x0d,0x0a,0x76,0x3d,0x30,0x0d,0x0a,0x6f,0x3d,
			    0x2d,0x20,0x36,0x20,0x32,0x20,0x49,0x4e,0x20,0x49,0x50,0x34,0x20,0x31,0x39,0x32,
			    0x2e,0x31,0x36,0x38,0x2e,0x31,0x30,0x31,0x2e,0x31,0x35,0x37,0x0d,0x0a,0x73,0x3d,
			    0x43,0x6f,0x75,0x6e,0x74,0x65,0x72,0x50,0x61,0x74,0x68,0x20,0x58,0x2d,0x4c,0x69,
			    0x74,0x65,0x20,0x33,0x2e,0x30,0x0d,0x0a,0x63,0x3d,0x49,0x4e,0x20,0x49,0x50,0x34,
			    0x20,0x31,0x39,0x32,0x2e,0x31,0x36,0x38,0x2e,0x31,0x30,0x31,0x2e,0x31,0x35,0x37,
			    0x0d,0x0a,0x74,0x3d,0x30,0x20,0x30,0x0d,0x0a,0x6d,0x3d,0x61,0x75,0x64,0x69,0x6f,
			    0x20,0x32,0x31,0x39,0x34,0x36,0x20,0x52,0x54,0x50,0x2f,0x41,0x56,0x50,0x20,0x31,
			    0x30,0x37,0x20,0x31,0x31,0x39,0x20,0x30,0x20,0x39,0x38,0x20,0x38,0x20,0x33,0x20,
			    0x31,0x30,0x31,0x0d,0x0a,0x61,0x3d,0x61,0x6c,0x74,0x3a,0x31,0x20,0x31,0x20,0x3a,
			    0x20,0x47,0x77,0x75,0x70,0x65,0x4e,0x6f,0x30,0x20,0x58,0x48,0x4a,0x47,0x62,0x4c,
			    0x49,0x72,0x20,0x31,0x39,0x32,0x2e,0x31,0x36,0x38,0x2e,0x31,0x30,0x31,0x2e,0x31,
			    0x35,0x37,0x20,0x32,0x31,0x39,0x34,0x36,0x0d,0x0a,0x61,0x3d,0x66,0x6d,0x74,0x70,
			    0x3a,0x31,0x30,0x31,0x20,0x30,0x2d,0x31,0x35,0x0d,0x0a,0x61,0x3d,0x72,0x74,0x70,
			    0x6d,0x61,0x70,0x3a,0x31,0x30,0x37,0x20,0x42,0x56,0x33,0x32,0x2f,0x31,0x36,0x30,
			    0x30,0x30,0x0d,0x0a,0x61,0x3d,0x72,0x74,0x70,0x6d,0x61,0x70,0x3a,0x31,0x31,0x39,
			    0x20,0x42,0x56,0x33,0x32,0x2d,0x46,0x45,0x43,0x2f,0x31,0x36,0x30,0x30,0x30,0x0d,
			    0x0a,0x61,0x3d,0x72,0x74,0x70,0x6d,0x61,0x70,0x3a,0x39,0x38,0x20,0x69,0x4c,0x42,
			    0x43,0x2f,0x38,0x30,0x30,0x30,0x0d,0x0a,0x61,0x3d,0x72,0x74,0x70,0x6d,0x61,0x70,
			    0x3a,0x31,0x30,0x31,0x20,0x74,0x65,0x6c,0x65,0x70,0x68,0x6f,0x6e,0x65,0x2d,0x65,
			    0x76,0x65,0x6e,0x74,0x2f,0x38,0x30,0x30,0x30,0x0d,0x0a,0x61,0x3d,0x73,0x65,0x6e,
			    0x64,0x72,0x65,0x63,0x76,0x0d,0x0a,0x00};

unsigned char sipmsg[] = { 0x53,0x49,0x50,0x2f,0x32,0x2e,
			   0x30,0x20,0x31,0x30,0x30,0x20,0x54,0x72,0x79,0x69,0x6e,0x67,0x0d,0x0a,0x56,0x69,
			   0x61,0x3a,0x20,0x53,0x49,0x50,0x2f,0x32,0x2e,0x30,0x2f,0x55,0x44,0x50,0x20,0x31,
			   0x39,0x32,0x2e,0x31,0x36,0x38,0x2e,0x31,0x30,0x31,0x2e,0x31,0x35,0x37,0x3a,0x36,
			   0x33,0x34,0x31,0x32,0x34,0x3b,0x62,0x72,0x61,0x6e,0x63,0x68,0x3d,0x7a,0x39,0x68,0x47,
			   0x34,0x62,0x4b,0x2d,0x64,0x38,0x37,0x35,0x34,0x33,0x2d,0x61,0x34,0x33,0x36,0x61,
			   0x34,0x34,0x66,0x63,0x35,0x31,0x32,0x33,0x34,0x32,0x38,0x2d,0x31,0x2d,0x2d,0x64,
			   0x38,0x37,0x35,0x34,0x33,0x2d,0x3b,0x72,0x65,0x63,0x65,0x69,0x76,0x65,0x64,0x3d,
			   0x31,0x39,0x32,0x2e,0x31,0x36,0x38,0x2e,0x31,0x30,0x31,0x2e,0x31,0x35,0x37,0x3b,
			   0x72,0x70,0x6f,0x72,0x74,0x3d,0x36,0x33,0x34,0x31,0x34,0x0d,0x0a,0x46,0x72,0x6f,
			   0x6d,0x3a,0x20,0x22,0x54,0x65,0x73,0x74,0x22,0x3c,0x73,0x69,0x70,0x3a,0x31,0x30,
			   0x31,0x30,0x40,0x31,0x39,0x32,0x2e,0x31,0x36,0x38,0x2e,0x31,0x30,0x31,0x2e,0x31,
			   0x3e,0x3b,0x74,0x61,0x67,0x3d,0x30,0x35,0x31,0x65,0x38,0x34,0x33,0x64,0x0d,0x0a,
			   0x54,0x6f,0x3a,0x20,0x22,0x31,0x30,0x31,0x31,0x22,0x3c,0x73,0x69,0x70,0x3a,0x31,
			   0x30,0x31,0x31,0x40,0x31,0x39,0x32,0x2e,0x31,0x36,0x38,0x2e,0x31,0x30,0x31,0x2e,
			   0x31,0x3e,0x0d,0x0a,0x43,0x61,0x6c,0x6c,0x2d,0x49,0x44,0x3a,0x20,0x5a,0x6d,0x51,
			   0x77,0x5a,0x54,0x49,0x77,0x5a,0x54,0x45,0x30,0x59,0x32,0x4d,0x79,0x59,0x7a,0x6b,
			   0x77,0x4e,0x7a,0x6c,0x6d,0x4e,0x44,0x6c,0x69,0x4d,0x32,0x4a,0x6a,0x4f,0x54,0x6b,
			   0x79,0x4e,0x32,0x46,0x6a,0x4e,0x57,0x55,0x2e,0x0d,0x0a,0x43,0x53,0x65,0x71,0x3a,
			   0x20,0x32,0x20,0x49,0x4e,0x56,0x49,0x54,0x45,0x0d,0x0a,0x55,0x73,0x65,0x72,0x2d,
			   0x41,0x67,0x65,0x6e,0x74,0x3a,0x20,0x41,0x73,0x74,0x65,0x72,0x69,0x73,0x6b,0x20,
			   0x50,0x42,0x58,0x0d,0x0a,0x41,0x6c,0x6c,0x6f,0x77,0x3a,0x20,0x49,0x4e,0x56,0x49,
			   0x54,0x45,0x2c,0x20,0x41,0x43,0x4b,0x2c,0x20,0x43,0x41,0x4e,0x43,0x45,0x4c,0x2c,
			   0x20,0x4f,0x50,0x54,0x49,0x4f,0x4e,0x53,0x2c,0x20,0x42,0x59,0x45,0x2c,0x20,0x52,
			   0x45,0x46,0x45,0x52,0x2c,0x20,0x53,0x55,0x42,0x53,0x43,0x52,0x49,0x42,0x45,0x2c,
			   0x20,0x4e,0x4f,0x54,0x49,0x46,0x59,0x0d,0x0a,0x53,0x75,0x70,0x70,0x6f,0x72,0x74,
			   0x65,0x64,0x3a,0x20,0x72,0x65,0x70,0x6c,0x61,0x63,0x65,0x73,0x0d,0x0a,0x43,0x6f,
			   0x6e,0x74,0x61,0x63,0x74,0x3a,0x20,0x3c,0x73,0x69,0x70,0x3a,0x31,0x30,0x31,0x31,
			   0x40,0x31,0x39,0x32,0x2e,0x31,0x36,0x38,0x2e,0x31,0x30,0x31,0x2e,0x31,0x3e,0x0d,
			   0x0a,0x43,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x4c,0x65,0x6e,0x67,0x74,0x68,0x3a,
			   0x20,0x30,0x0d,0x0a,0x0d,0x0a,0x00};

extern unsigned char sipmsgT[][1500];
extern int sizeT;


int
getvalue(unsigned int v)
{
  
  static int      cval1[] = {
                0, 37, 211, 219, 28, 0, 197, 166, 253, 0,
                66, 201, 226, 59, 0, 22, 35, 163, 0, 32,
                219, 195, 84, 202, 184, 0, 176, 37, 249, 162,
                125, 197, 0, 227, 0, 0, 0, 0, 0, 0,
                73, 214, 0, 0, 121, 89, 6, 66, 0, 0,
                0, 63, 0, 56, 18, 229, 0, 0, 43, 0,
                197, 163, 24, 0, 165, 207, 59, 83, 262, 86,
                28, 101, 21, 218, 10, 232, 200, 173, 90, 152,
                155, 163, 121, 9, 252, 211, 75, 71, 206, 115,
                33, 4, 221, 219, 51, 141, 0, 0, 0, 0,
                159, 110, 225, 0, 0, 176, 218, 0, 258, 0,
                11, 262, 0, 231, 0, 0, 0, 0, 0, 0,
                0, 21, 227, 164, 216, 72, 0,
        };
   static int      cval[] = {
                0, 37, 211, 219, 28, 0, 0, 197, 166, 0,
                253, 66, 201, 226, 0, 0, 59, 22, 0, 35,
                163, 32, 4, 195, 69, 0, 202, 184, 176, 188,
                249, 162, 0, 125, 0, 0, 0, 0, 0, 0,
                253, 227, 0, 0, 73, 214, 0, 201, 0, 0,
                0, 89, 0, 6, 66, 63, 0, 0, 28, 0,
                219, 229, 43, 0, 0, 0, 106, 211, 24, 165,
                207, 59, 83, 262, 86, 11, 101, 21, 218, 10,
                232, 200, 173, 90, 152, 197, 163, 121, 9, 252,
                128, 75, 71, 206, 115, 33, 0, 0, 0, 0,
                4, 221, 0, 0, 0, 219, 51, 0, 0, 0,
                141, 159, 0, 110, 0, 0, 0, 0, 0, 0,
                0, 166, 176, 218, 258, 11, 0,
        };
  unsigned char c0, c1, c2, c3;
  c0 =  (v>>24) & 0xff; 
  c1 =  (v>>16) & 0xff; 
  c2 =  (v>>8) & 0xff;
  c3 =  (v>>0) & 0xff;

  printf("00000: %x = cval[%d]= %d + cval[%d]= %d \n", v, c3  ,cval[c3],c0  ,cval[c0]);
 
    return cval1[c3]  + cval[c0]*3;
 
}

int
printCode()
{
  unsigned char c0, c1, c2, c3;
  unsigned int v;
  int i;
  for (i = 0; sipHeaders[i].vector; i++)
    {
      printf("%04d: {\033[4;40m\033[32m\033[4;40m\033[32m%s\033[m} %08x/%d \n",getvalue(sipHeaders[i].code), sipHeaders[i].vector,sipHeaders[i].code, i);
      v = sipHeaders[i].code;
      c0 =  (v>>24) & 0xff; 
      c1 =  (v>>16) & 0xff; 
      c2 =  (v>>8) & 0xff;
      c3 =  (v>>0) & 0xff;
      

    }
}



int 
main(int argc, char *argv[])
{
  int i,j, n;
  struct preparse pre[200];
  char *buff = malloc(200);
  unsigned int tcrc;

  unsigned char *msg;
  
  

#if 0
  msg = sipmsgT[12];
  
  n = crlf_trigger(msg, strlen(msg), pre, 200);
  for(i =0; i < n &&  pre[i].start != 0; i++)
    {
      strncpy(buff, pre[i].start , pre[i].end -  pre[i].start);
      buff[pre[i].end -  pre[i].start] = '\0';
      prncrx(i, pre, buff);
    }
#else 
  for ( j = 0; j < 20; j++)
    {
      memset(pre, 0,
             sizeof(pre));
      n =  crlf_trigger(sipmsgT[j], strlen(sipmsgT[j]), pre, 200);
      printf("\nmsg [%d]:\n", j);
      
      
      for(i =0; i < n; i++)
	{
          msg = (char *) pre[i].end;
          if (*msg == '\015')
            *msg = '\0';
	  strncpy(buff, pre[i].start , pre[i].end -  pre[i].start);
          
	  buff[pre[i].end -  pre[i].start] = '\0';
	  prncrx(i, pre, buff);
	}
    }     
  #endif
  //printCode();
  return 0;
}
