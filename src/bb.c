#define HSIZESHIFT 4
#define HSIZE (1 << HSIZESHIFT)
/* 256 random numbers generated by a quantum source */
static unsigned int noise[256] =
{
0x9be502a4U, 0xba7180eaU, 0x324e474fU, 0x0aab8451U, 0x0ced3810U,
0x2158a968U, 0x6bbd3771U, 0x75a02529U, 0x41f05c14U, 0xc2264b87U,
0x1f67b359U, 0xcd2d031dU, 0x49dc0c04U, 0xa04ae45cU, 0x6ade28a7U,
0x2d0254ffU, 0xdec60c7cU, 0xdef5c084U, 0x0f77ffc8U, 0x112021f6U,
0x5f6d581eU, 0xe35ea3dfU, 0x3216bfb4U, 0xd5a3083dU, 0x7e63e9cdU,
0xaa9208f6U, 0xda3f3978U, 0xfe0e2547U, 0x09dfb020U, 0xd97472c5U,
0xbbce2edeU, 0x121aebd2U, 0x0e9fdbebU, 0x7b6f5d9cU, 0x84938e43U,
0x30694f2dU, 0x86b7a7f8U, 0xefaf5876U, 0x263812e6U, 0xb6e48ddfU,
0xce8ed980U, 0x4df591e1U, 0x75257b35U, 0x2f88dcffU, 0xa461fe44U,
0xca613b4dU, 0xd9803f73U, 0xea056205U, 0xccca7a89U, 0x0f2dbb07U,
0xc53e359eU, 0xe80d0137U, 0x2b2d2a5dU, 0xcfc1391aU, 0x2bb3b6c5U,
0xb66aea3cU, 0x00ea419eU, 0xce5ada84U, 0xae1d6712U, 0x12f576baU,
0x117fcbc4U, 0xa9d4c775U, 0x25b3d616U, 0xefda65a8U, 0xaff3ef5bU,
0x00627e68U, 0x668d1e99U, 0x088d0eefU, 0xf8fac24dU, 0xe77457c7U,
0x68d3beb4U, 0x921d2acbU, 0x9410eac9U, 0xd7f24399U, 0xcbdec497U,
0x98c99ae1U, 0x65802b2cU, 0x81e1c3c4U, 0xa130bb09U, 0x17a87badU,
0xa70367d6U, 0x148658d4U, 0x02f33377U, 0x8620d8b6U, 0xbdac25bdU,
0xb0a6de51U, 0xd64c4571U, 0xa4185ba0U, 0xa342d70fU, 0x3f1dc4c1U,
0x042dc3ceU, 0x0de89f43U, 0xa69b1867U, 0x3c064e11U, 0xad1e2c3eU,
0x9660e8cdU, 0xd36b09caU, 0x4888f228U, 0x61a9ac3cU, 0xd9561118U,
0x3532797eU, 0x71a35c22U, 0xecc1376cU, 0xab31e656U, 0x88bd0d35U,
0x423b20ddU, 0x38e4651cU, 0x3c6397a4U, 0x4a7b12d9U, 0x08b1cf33U,
0xd0604137U, 0xb035fdb8U, 0x4916da23U, 0xa9349493U, 0xd83daa9bU,
0x145f7d95U, 0x868531d6U, 0xacb18f17U, 0x9cd33b6fU, 0x193e42b9U,
0x26dfdc42U, 0x5069d8faU, 0x5bee24eeU, 0x5475d4c6U, 0x315b2c0cU,
0xf764ef45U, 0x01b6f4ebU, 0x60ba3225U, 0x8a16777cU, 0x4c05cd28U,
0x53e8c1d2U, 0xc8a76ce5U, 0x8045c1e6U, 0x61328752U, 0x2ebad322U,
0x3444f3e2U, 0x91b8af11U, 0xb0cee675U, 0x55dbff5aU, 0xf7061ee0U,
0x27d7d639U, 0xa4aef8c9U, 0x42ff0e4fU, 0x62755468U, 0x1c6ca3f3U,
0xe4f522d1U, 0x2765fcb3U, 0xe20c8a95U, 0x3a69aea7U, 0x56ab2c4fU,
0x8551e688U, 0xe0bc14c2U, 0x278676bfU, 0x893b6102U, 0xb4f0ab3bU,
0xb55ddda9U, 0xa04c521fU, 0xc980088eU, 0x912aeac1U, 0x08519badU,
0x991302d3U, 0x5b91a25bU, 0x696d9854U, 0x9ad8b4bfU, 0x41cb7e21U,
0xa65d1e03U, 0x85791d29U, 0x89478aa7U, 0x4581e337U, 0x59bae0b1U,
0xe0fc9df3U, 0x45d9002cU, 0x7837464fU, 0xda22de3aU, 0x1dc544bdU,
0x601d8badU, 0x668b0abcU, 0x7a5ebfb1U, 0x3ac0b624U, 0x5ee16d7dU,
0x9bfac387U, 0xbe8ef20cU, 0x8d2ae384U, 0x819dc7d5U, 0x7c4951e7U,
0xe60da716U, 0x0c5b0073U, 0xb43b3d97U, 0xce9974edU, 0x0f691da9U,
0x4b616d60U, 0x8fa9e819U, 0x3f390333U, 0x6f62fad6U, 0x5a32b67cU,
0x3be6f1c3U, 0x05851103U, 0xff28828dU, 0xaa43a56aU, 0x075d7dd5U,
0x248c4b7eU, 0x52fde3ebU, 0xf72e2edaU, 0x5da6f75fU, 0x2f5148d9U,
0xcae2aeaeU, 0xfda6f3e5U, 0xff60d8ffU, 0x2adc02d2U, 0x1dbdbd4cU,
0xd410ad7cU, 0x8c284aaeU, 0x392ef8e0U, 0x37d48b3aU, 0x6792fe9dU,
0xad32ddfaU, 0x1545f24eU, 0x3a260f73U, 0xb724ca36U, 0xc510d751U,
0x4f8df992U, 0x000b8b37U, 0x292e9b3dU, 0xa32f250fU, 0x8263d144U,
0xfcae0516U, 0x1eae2183U, 0xd4af2027U, 0xc64afae3U, 0xe7b34fe4U,
0xdf864aeaU, 0x80cc71c5U, 0x0e814df3U, 0x66cc5f41U, 0x853a497aU,
0xa2886213U, 0x5e34a2eaU, 0x0f53ba47U, 0x718c484aU, 0xfa0f0b12U,
0x33cc59ffU, 0x72b48e07U, 0x8b6f57bcU, 0x29cf886dU, 0x1950955bU,
0xcd52910cU, 0x4cecef65U, 0x05c2cbfeU, 0x49df4f6aU, 0x1f4c3f34U,
0xfadc1a09U, 0xf2d65a24U, 0x117f5594U, 0xde3a84e6U, 0x48db3024U,
0xd10ca9b5U
};
/* buzhash by Robert C. Uzgalis */
/* General hash functions. Technical Report TR-92-01, The University
of Hong Kong, 1993 */
static unsigned int buzhash(unsigned char *buf)
{
unsigned int x = 0x83d31df4U;
int i;
for (i = HSIZE; i != 0; i--)
x = (x << 1) ^ (x & (1 << 31) ? 1 : 0) ^ noise[*buf++];
return x;
}
static unsigned int primes[] =
{
65537, 98317, 147481, 221227, 331841, 497771, 746659, 1120001,
1680013, 2520031, 3780053, 5670089, 8505137, 12757739, 19136609,
28704913, 43057369, 64586087, 96879131, 145318741, 217978121,
326967209, 490450837, 735676303, 1103514463, 1655271719,
0xffffffff
};





#include "buzhash.h"
#include <string.h>
#include <stdlib.h>

const hash_t CHAR2LONG[255] = {
    12658332951230890439ul,
    16607337219466274820ul,
    4897781435750669512ul,
    1863954398247708433ul,
    6041299601906237138ul,
    3602934247356726349ul,
    13927570682514441143ul,
    11920701378039577834ul,
    14629533900929623503ul,
    16546862913458629335ul,
    10685855460932754325ul,
    15186106020611570871ul,
    8131473594228677807ul,
    9287569521752445451ul,
    5624316205208212365ul,
    10693223548395698341ul,
    10578473704599778022ul,
    16693921798782755893ul,
    15124492184888274523ul,
    1235529881146962610ul,
    14843219789508576687ul,
    15526012670070475388ul,
    6463116610490435782ul,
    15104307767477900194ul,
    8484741665705462025ul,
    8100868536101218192ul,
    3395269876321120613ul,
    8589680476807032865ul,
    7621819336684948355ul,
    14153065448097834589ul,
    6732762317790231782ul,
    13018363043978374122ul,
    6215216690161075437ul,
    9357943660640904950ul,
    12116224851753945911ul,
    13636661669728066501ul,
    7484247892091601413ul,
    8512193125891820287ul,
    10461835854496665155ul,
    16797036920317134766ul,
    1313270971513831546ul,
    742840173802188917ul,
    1249430170856643161ul,
    17179028999057074571ul,
    6378210156955744140ul,
    793680677819467304ul,
    4263415984887072454ul,
    7875662396850393478ul,
    17050561532048146107ul,
    1435098142595853720ul,
    8580942225888237636ul,
    13308656650323976644ul,
    16630067181906003651ul,
    12116795942522001627ul,
    9892291673171748547ul,
    11660673438127243284ul,
    6026050291617469826ul,
    10478522635079777192ul,
    12138158317934008218ul,
    3518644136578100667ul,
    4950215611630576830ul,
    15769242181285477405ul,
    7950690203065752077ul,
    319974224259159447ul,
    9604177767109474443ul,
    2499971183666009670ul,
    3389512945436469180ul,
    13643083464485449791ul,
    7197237438818751483ul,
    11151212581995191915ul,
    17495196072216154799ul,
    6770497232845758508ul,
    10987981514044724191ul,
    14707120191905416074ul,
    1769092362238593010ul,
    9329650998411009452ul,
    14719126903328637772ul,
    16952770464905740286ul,
    9674713352706546441ul,
    6649376341374010415ul,
    13209384319143003802ul,
    15927169943220646170ul,
    16897589646525214220ul,
    3262252579774962994ul,
    12644188031911778084ul,
    12242729612781990566ul,
    10411593575032306840ul,
    6901591497302664456ul,
    16282753866514979972ul,
    1656537748780076590ul,
    16482447327676653424ul,
    15257560081058078415ul,
    2959473391892618753ul,
    6837204821782891114ul,
    10938562237399133186ul,
    16857781777840528196ul,
    8483325299592247627ul,
    8376541859638180551ul,
    2504977066327782390ul,
    12231409223811250404ul,
    4744310199064570243ul,
    17936677873798959622ul,
    7126990633455442871ul,
    2079219814712678870ul,
    5067179041865164597ul,
    2311488369720591961ul,
    1725854410047761352ul,
    7355938747639265690ul,
    15490596914355917847ul,
    2283460595124192686ul,
    6878856348493276219ul,
    9152647736939983958ul,
    1662432522495537695ul,
    11306127178924536002ul,
    9272318044070549747ul,
    7145744474881723964ul,
    13448381548771200536ul,
    16160887140379377718ul,
    16369357319459660843ul,
    5476117262347077406ul,
    16602075379238506563ul,
    11456607228896734049ul,
    6465411526782391145ul,
    8155612729101736593ul,
    1740403063688953650ul,
    4466509242016709213ul,
    18112502299939680520ul,
    16974090059556845575ul,
    12326512096507303015ul,
    15376655537080530798ul,
    12498441914565269305ul,
    6036826437421754258ul,
    7912527257991934972ul,
    16620739722007677741ul,
    8733477150731820655ul,
    16564684276929490022ul,
    9409261669616170022ul,
    8387885649776441101ul,
    4427301691848253832ul,
    17640389513959398145ul,
    11987577927023442578ul,
    1358867256273478740ul,
    14172638869615591470ul,
    4669134809929205329ul,
    9146890779639199412ul,
    2448139160410716046ul,
    14539456923687813097ul,
    15701779011641704372ul,
    12184110908386419117ul,
    6182072944631238310ul,
    6068503614243670324ul,
    17486237705261861510ul,
    8141926135459860042ul,
    11247558917664640122ul,
    15966973352605162329ul,
    9274584296089522436ul,
    16106837601580129961ul,
    5565067011055473713ul,
    9018591362895332601ul,
    17429669259725580644ul,
    5862130260298638241ul,
    10804107644379464482ul,
    14590678293851680311ul,
    7586397638435564357ul,
    5024282990565981028ul,
    17710866669113912150ul,
    10607302159042519593ul,
    10224690187282473862ul,
    12691341730791771243ul,
    446919220230245087ul,
    11928822690215012312ul,
    14695552131553031715ul,
    9373710656266261295ul,
    10535666776941439244ul,
    4764286487123496201ul,
    12081558227095427560ul,
    14657526787837780677ul,
    4854775944749701021ul,
    18014893051074447624ul,
    5961551484053396826ul,
    7007393494224833114ul,
    1918625258470397717ul,
    2249596653018019968ul,
    15376752853428300944ul,
    15661589396388907215ul,
    17959491169395034186ul,
    7412669116831624121ul,
    16613322186307011607ul,
    1168394068192978862ul,
    13541384245715877822ul,
    17842264847294623193ul,
    8656129051250713732ul,
    6600363660893585591ul,
    10437456264051898071ul,
    6483876479559582910ul,
    2351460095187333222ul,
    17709647483310915437ul,
    4687819186773626811ul,
    12859142186029646747ul,
    14196439022719216916ul,
    10831194418958921226ul,
    9958754500157295475ul,
    2812703802823563549ul,
    364639487745161427ul,
    18071223067394944401ul,
    11148005916176784196ul,
    10887057658503987840ul,
    7239832157577921295ul,
    6274798767279704963ul,
    9654930315473449062ul,
    11342083202968693359ul,
    8060885109403789727ul,
    532804797012507628ul,
    4259820420986796757ul,
    3591121934050292837ul,
    3739649723128072566ul,
    11338759925899470208ul,
    17557031182161531657ul,
    1328316363081986551ul,
    905104119772647733ul,
    16162805969666123858ul,
    13351191969939227039ul,
    11181921000405417530ul,
    1257129276560696939ul,
    8049492553042309720ul,
    8867122601488545729ul,
    8169023185794623188ul,
    14027174324336484013ul,
    3026556086188399794ul,
    7137339202398299406ul,
    15636400854018083176ul,
    1912758983363371197ul,
    12934014134659659938ul,
    6432162334519755563ul,
    11890239098696368321ul,
    465021739668949123ul,
    3571688800220472097ul,
    17356096479830501074ul,
    17244551474859817129ul,
    16858016682994011520ul,
    11599911656842386375ul,
    1384801604554958238ul,
    10350053496655489375ul,
    2028044935420165668ul,
    9321839731809955516ul,
    3800717409646038380ul,
    508616612214119935ul,
    14489270436014461891ul,
    11373150082561320490ul,
    8855221204049336307ul,
    11920562817555372746ul,
    17464569634060446109ul,
    146583913832133545ul,
    11454565731520647642ul,
    14516679283835536061ul,
};

// 64-bit left circular shift
hash_t rotate_left(hash_t value, int shift) {
    return (value << shift) | (value >> (64 - shift));
}

hash_t hash_string(char* string) {
    hash_t hash = 0;
    int string_len = strlen(string);
    int i;
    for (i=0; i<string_len; i++) {
        hash ^= CHAR2LONG[(unsigned char) string[i]];
        hash = rotate_left(hash, 1);
    }
    return hash;
}

void buzhash_init_buffer(buzhash_buffer_t* buffer, int size) {
    buffer->size = size;
    buffer->elem_count = 0;
    buffer->last_index = size - 1;
    buffer->hash = 0;
    buffer->elems = (hash_t*) malloc(size * sizeof(hash_t));
}

void buzhash_clear_buffer(buzhash_buffer_t* buffer) {
    buffer->elem_count = 0;
    buffer->last_index = buffer->size - 1;
    buffer->hash = 0;
}

void buzhash_free_buffer(buzhash_buffer_t* buffer) {
    free(buffer->elems);
}

int buzhash_is_full_buffer(buzhash_buffer_t* buffer) {
    return (buffer->elem_count == buffer->size);
}

hash_t buzhash(char* string, buzhash_buffer_t* buffer) {
    hash_t string_hash = hash_string(string);
    if (buffer->elem_count < buffer->size) {
        buffer->last_index = (buffer->last_index + 1) % buffer->size;
        buffer->hash = rotate_left(buffer->hash, 1) ^ string_hash;
        buffer->elems[buffer->last_index] = string_hash;
        buffer->elem_count++;
    }
    else {
        int fst_index = (buffer->last_index + 1) % buffer->size;
        buffer->hash = rotate_left(buffer->hash, 1) ^ rotate_left(
                buffer->elems[fst_index], buffer->size) ^ string_hash;
        buffer->last_index = fst_index;
        buffer->elems[buffer->last_index] = string_hash;
    }
    return buffer->hash;
}

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <sys/queue.h>

#include "binheap.h"

/**********************************************************************
 * algo = 0:	classic array based.
 * algo = 1:	ditto, but with index shifted one down to use index 0
 * algo = 2:	VM aware, strict tree, but wasting to indicies per page
 * algo = 3:	ditto, but put those to indicies per page to use
 */

static unsigned bh_psize;
static unsigned bh_shift;
static unsigned bh_mask;
static unsigned bh_hshift;
static unsigned bh_hmask;
static unsigned bh_half;
static unsigned bh_len;
static unsigned bh_algo;

static uintptr_t
bh_rd(unsigned idx)
{

	assert(idx <= bh_len);
	if (bh_algo == 1)
		idx--;
	return (VM_rd(idx >> bh_shift, idx & bh_mask));
}

static void
bh_wr(unsigned idx, uintptr_t val)
{

	assert(idx <= bh_len);
	if (bh_algo == 1)
		idx--;
	VM_wr(idx >> bh_shift, idx & bh_mask, val);
}

static unsigned
bh_pg(unsigned idx)
{

	return (idx >> bh_shift);
}

static unsigned
bh_po(unsigned idx)
{

	return (idx & bh_mask);
}

static void
bh_bubble_up(unsigned idx, unsigned v)
{
	unsigned ip, pv;
	unsigned po, pg;

	while (idx > 1) {
		if (bh_algo < 2) {
			ip = idx / 2;
		} else if (bh_algo == 2) {
			pg = bh_pg(idx);
			po = bh_po(idx);
			if (pg > 0 && po < 4) {
				assert(po == 2 || po == 3);
				ip = ((pg - 1) >> bh_hshift) << bh_shift;
				ip += ((pg - 1) & bh_hmask) + bh_half;
			} else {
				ip = (idx & ~bh_mask) + po / 2;
			}
		} else if (bh_algo == 3) {
			po = bh_po(idx);
			if (idx < bh_psize || po > 3) {
				ip = (idx & ~bh_mask) | (po >> 1);
			} else if (po < 2) {
				ip = (idx - bh_psize) >> bh_shift;
				ip += (ip & ~bh_hmask);
				ip |= bh_psize / 2;
			} else {
				ip = idx - 2;
			}
		} else {
			ip = 0;
			assert(__LINE__);
		}

		pv = bh_rd(ip);
		if (pv < v)
			return;
		bh_wr(ip, v);
		bh_wr(idx, pv);
		idx = ip;
	}
}

static void
bh_bubble_down(unsigned idx, unsigned v)
{
	unsigned i1, i2, v1, v2;
	unsigned po, pg;

	while (idx < bh_len) {
		if (bh_algo < 2) {
			i1 = idx * 2;
			i2 = i1 + 1;
		} else if (bh_algo == 2) {
			pg = bh_pg(idx);
			po = bh_po(idx);
			if (po < bh_half) {
				i1 = (idx & ~bh_mask) + po * 2;
			} else {
				i1 = (pg << bh_hshift) + (po - bh_half) + 1;
				i1 <<= bh_shift;
				i1 += 2;
			}
			i2 = i1 + 1;
		} else if (bh_algo == 3) {
			if (idx > bh_mask && !(idx & (bh_mask - 1))) {
				/* first two elements in nonzero pages */
				i1 = i2 = idx + 2;
			} else if (idx & (bh_psize >> 1)) {
				/* Last row of page */
				i1 = (idx & ~bh_mask) >> 1;
				i1 |= idx & (bh_mask >> 1);
				i1 += 1;
				i1 <<= bh_shift;
				i2 = i1 + 1;
			} else {
				i1 = idx + (idx & bh_mask);
				i2 = i1 + 1;
			}
		} else {
			i1 = 0;
			i2 = i1 + 1;
			assert(__LINE__);
		}
		if (i1 != i2 && i2 <= bh_len) {
			v1 = bh_rd(i1);
			v2 = bh_rd(i2);
			if (v1 < v && v1 <= v2) {
				bh_wr(i1, v);
				bh_wr(idx, v1);
				idx = i1;
			} else if (v2 < v) {
				bh_wr(i2, v);
				bh_wr(idx, v2);
				idx = i2;
			} else {
				break;
			}
		} else if (i1 <= bh_len) {
			v1 = bh_rd(i1);
			if (v1 < v) {
				bh_wr(i1, v);
				bh_wr(idx, v1);
				idx = i1;
			} else {
				break;
			}
		} else
			break;
	}
}

void
bh_init(unsigned algo, unsigned psz)
{
	unsigned u;

	/* Calculate the log2(psz) */
	assert((psz & (psz - 1)) == 0);	/* Must be power of two */
	for (u = 1; (1U << u) != psz; u++)
		;
	bh_shift = u;
	bh_mask = psz - 1;

	bh_half = psz / 2;
	bh_hshift = bh_shift - 1;
	bh_hmask = bh_mask >> 1;
	
	bh_len = 0;
	bh_algo = algo;
	bh_psize = psz;
}

void
bh_insert(unsigned val)
{
	
	bh_len++;
	if (bh_algo == 2) {
		if (bh_po(bh_len) == 0)
			bh_len += 2;
	}
	bh_wr(bh_len, val);
	bh_bubble_up(bh_len, val);
}

unsigned
bh_remove(void)
{
	unsigned val, retval;

	retval = bh_rd(1);
	val = bh_rd(bh_len);
	bh_len--;
	if (bh_len == 0)
		return (retval);
	if (bh_algo == 2) {
		if (bh_pg(bh_len) > 0 && bh_po(bh_len) == 1)
			bh_len-=2;
	}
	bh_wr(1, val);
	bh_bubble_down(1, val);
	return (retval);
}

; -----------------------------------------------------------------------
  ; in place tokenise CRLF delimited text and write an array of pointers
  ; to each line to a passed address and return the line count in EAX

  ; ********************************************************************
  ; invoke line_tokenize,pTxt,ADDR hArray  ; <<< note the ADDR of hArray
  ; ********************************************************************

  ; --------
  ; On ENTRY
  ; --------
  ; ptxt is the address of the text to tokenize.
  ; hArr is the address of a variable to receive the pointer array address

  ; -------
  ; On EXIT
  ; -------
  ; 1. pointer array has the address of each line
  ; 2. the return value in EAX is the line count

  ; -------------------------------
  ; When data is no longer required
  ; -------------------------------
  ; The passed variable "hArr" must be freed with GlobalFree()
  ; or the macro "free"

  ; NOTE: An empty line of text has ZERO as its first character
  ; and the array pointer for that line points to that ZERO.
  ; When you process the content or the array you must be able
  ; to safely deal with pointers to null terminated zero length strings.
  ; -----------------------------------------------------------------------

    mov ecx, [esp+4]            ; ptxt
    xor edx, edx                ; zero counter
    sub ecx, 1

  ; --------------------------
  ; count the carriage returns
  ; --------------------------
  cntloop:
    add ecx, 1
    movzx eax, BYTE PTR [ecx]   ; zero extend each byte into EAX
    test eax, eax               ; test for zero
    jz lout                     ; exit loop on zero
    cmp eax, 13                 ; test for carriage return
    jne cntloop                 ; loop back if not
    add edx, 1                  ; increment counter
    jmp cntloop                 ; loop back

  ; -----------------------------------
  ; set buffer size and allocate memory
  ; -----------------------------------
  lout:
    add edx, 1                  ; allow for no trailing CRLF
    push edx                    ; preserve count on stack
    lea edx, [edx*4]            ; mul edx * 4
    mov edx, alloc(edx)         ; allocate the pointer array memory
    mov eax, [esp+8][4]         ; hArr - write the passed handle address to EAX
    mov [eax], edx              ; write the allocated memory handle to it
    mov ecx, [esp+4][4]         ; ptxt - text address in ECX
    mov [edx], ecx              ; 1st line address in 1st DWORD in EDX
    add edx, 4
    sub ecx, 1

  mainloop:
    add ecx, 1
  backin:
    movzx eax, BYTE PTR [ecx]   ; test each byte
    test eax, eax               ; exit on zero
    jz lpout
    cmp eax, 13                 ; test for CR
    jne mainloop                ; loop back if not

    mov BYTE PTR [ecx], 0       ; overwrite 13 with 0
    add ecx, 2                  ; set next line start
    mov [edx], ecx              ; store it in the pointer array
    add edx, 4
    jmp backin
    
  lpout:
    pop eax                     ; restore count into EAX as return value

    ret 8

line_tokenize endp

OPTION PROLOGUE:PrologueDef
OPTION EPILOGUE:EpilogueDef

; ¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤

end start
OPT_Tmp2Asm	1
